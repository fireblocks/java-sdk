/*
 * Fireblocks API
 * Fireblocks provides a suite of applications to manage digital asset operations and a complete development platform to build your business on the blockchain.  - Visit our website for more information: [Fireblocks Website](https://fireblocks.com) - Visit our developer docs: [Fireblocks DevPortal](https://developers.fireblocks.com)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: developers@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.fireblocks.sdk.api;


import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fireblocks.sdk.ApiClient;
import com.fireblocks.sdk.ApiException;
import com.fireblocks.sdk.ApiResponse;
import com.fireblocks.sdk.Pair;
import com.fireblocks.sdk.ValidationUtils;
import com.fireblocks.sdk.model.CreateAddressRequest;
import com.fireblocks.sdk.model.CreateAddressResponse;
import com.fireblocks.sdk.model.CreateAssetsRequest;
import com.fireblocks.sdk.model.CreateMultipleAccountsRequest;
import com.fireblocks.sdk.model.CreateMultipleDepositAddressesJobStatus;
import com.fireblocks.sdk.model.CreateMultipleDepositAddressesRequest;
import com.fireblocks.sdk.model.CreateMultipleVaultAccountsJobStatus;
import com.fireblocks.sdk.model.CreateVaultAccountRequest;
import com.fireblocks.sdk.model.CreateVaultAssetResponse;
import com.fireblocks.sdk.model.GetMaxBipIndexUsedResponse;
import com.fireblocks.sdk.model.GetMaxSpendableAmountResponse;
import com.fireblocks.sdk.model.JobCreated;
import com.fireblocks.sdk.model.PaginatedAddressResponse;
import com.fireblocks.sdk.model.PaginatedAssetWalletResponse;
import com.fireblocks.sdk.model.PublicKeyInformation;
import com.fireblocks.sdk.model.RenameVaultAccountResponse;
import com.fireblocks.sdk.model.SetAutoFuelRequest;
import com.fireblocks.sdk.model.SetCustomerRefIdForAddressRequest;
import com.fireblocks.sdk.model.SetCustomerRefIdRequest;
import com.fireblocks.sdk.model.UnspentInputsResponse;
import com.fireblocks.sdk.model.UpdateVaultAccountAssetAddressRequest;
import com.fireblocks.sdk.model.UpdateVaultAccountRequest;
import com.fireblocks.sdk.model.VaultAccount;
import com.fireblocks.sdk.model.VaultAccountsPagedResponse;
import com.fireblocks.sdk.model.VaultAccountsTagAttachmentOperationsRequest;
import com.fireblocks.sdk.model.VaultAccountsTagAttachmentOperationsResponse;
import com.fireblocks.sdk.model.VaultActionStatus;
import com.fireblocks.sdk.model.VaultAsset;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigDecimal;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.StringJoiner;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;

@jakarta.annotation.Generated(
        value = "org.openapitools.codegen.languages.JavaClientCodegen",
        comments = "Generator version: 7.14.0")
public class VaultsApi {
    private final HttpClient memberVarHttpClient;
    private final ObjectMapper memberVarObjectMapper;
    private final String memberVarBaseUri;
    private final Consumer<HttpRequest.Builder> memberVarInterceptor;
    private final Duration memberVarReadTimeout;
    private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
    private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

    public VaultsApi() {
        this(new ApiClient());
    }

    public VaultsApi(ApiClient apiClient) {
        memberVarHttpClient = apiClient.getHttpClient();
        memberVarObjectMapper = apiClient.getObjectMapper();
        memberVarBaseUri = apiClient.getBaseUri();
        memberVarInterceptor = apiClient.getRequestInterceptor();
        memberVarReadTimeout = apiClient.getReadTimeout();
        memberVarResponseInterceptor = apiClient.getResponseInterceptor();
        memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
    }

    private ApiException getApiException(String operationId, HttpResponse<String> response) {
        String message =
                formatExceptionMessage(operationId, response.statusCode(), response.body());
        return new ApiException(
                response.statusCode(), message, response.headers(), response.body());
    }

    private String formatExceptionMessage(String operationId, int statusCode, String body) {
        if (body == null || body.isEmpty()) {
            body = "[no body]";
        }
        return operationId + " call failed with: " + statusCode + " - " + body;
    }

    /**
     * Activate a wallet in a vault account Initiates activation for a wallet in a vault account.
     * Activation is required for tokens that need an on-chain transaction for creation (XLM tokens,
     * SOL tokens etc). &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver,
     * Editor.
     *
     * @param vaultAccountId The ID of the vault account to return, or &#39;default&#39; for the
     *     default vault account (required)
     * @param assetId The ID of the asset (required)
     * @param idempotencyKey A unique identifier for the request. If the request is sent multiple
     *     times with the same idempotency key, the server will return the same response as the
     *     first request. The idempotency key is valid for 24 hours. (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;CreateVaultAssetResponse&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<CreateVaultAssetResponse>> activateAssetForVaultAccount(
            String vaultAccountId, String assetId, String idempotencyKey) throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    activateAssetForVaultAccountRequestBuilder(
                            vaultAccountId, assetId, idempotencyKey);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "activateAssetForVaultAccount",
                                                    localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<CreateVaultAssetResponse>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            CreateVaultAssetResponse>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder activateAssetForVaultAccountRequestBuilder(
            String vaultAccountId, String assetId, String idempotencyKey) throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "activateAssetForVaultAccount", "vaultAccountId", vaultAccountId);
        ValidationUtils.assertParamExistsAndNotEmpty(
                "activateAssetForVaultAccount", "assetId", assetId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/{assetId}/activate"
                        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
                        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        if (idempotencyKey != null) {
            localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
        }
        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Attach or detach tags from vault accounts Attach or detach one or more tags from the
     * requested vault accounts. Endpoint Permission: For protected tags: Owner, Admin, Non-Signing
     * Admin. For non protected tags: Owner, Admin, Non-Signing Admin, Signer, Editor, Approver.
     *
     * @param vaultAccountsTagAttachmentOperationsRequest (required)
     * @param idempotencyKey A unique identifier for the request. If the request is sent multiple
     *     times with the same idempotency key, the server will return the same response as the
     *     first request. The idempotency key is valid for 24 hours. (optional)
     * @return
     *     CompletableFuture&lt;ApiResponse&lt;VaultAccountsTagAttachmentOperationsResponse&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<VaultAccountsTagAttachmentOperationsResponse>>
            attachOrDetachTagsFromVaultAccounts(
                    VaultAccountsTagAttachmentOperationsRequest
                            vaultAccountsTagAttachmentOperationsRequest,
                    String idempotencyKey)
                    throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    attachOrDetachTagsFromVaultAccountsRequestBuilder(
                            vaultAccountsTagAttachmentOperationsRequest, idempotencyKey);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "attachOrDetachTagsFromVaultAccounts",
                                                    localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<
                                                    VaultAccountsTagAttachmentOperationsResponse>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            VaultAccountsTagAttachmentOperationsResponse>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder attachOrDetachTagsFromVaultAccountsRequestBuilder(
            VaultAccountsTagAttachmentOperationsRequest vaultAccountsTagAttachmentOperationsRequest,
            String idempotencyKey)
            throws ApiException {
        ValidationUtils.assertParamExists(
                "attachOrDetachTagsFromVaultAccounts",
                "vaultAccountsTagAttachmentOperationsRequest",
                vaultAccountsTagAttachmentOperationsRequest);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath = "/vault/accounts/attached_tags";

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        if (idempotencyKey != null) {
            localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
        }
        localVarRequestBuilder.header("Content-Type", "application/json");
        localVarRequestBuilder.header("Accept", "application/json");

        try {
            byte[] localVarPostBody =
                    memberVarObjectMapper.writeValueAsBytes(
                            vaultAccountsTagAttachmentOperationsRequest);
            localVarRequestBuilder.method(
                    "POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
        } catch (IOException e) {
            throw new ApiException(e);
        }
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Convert a segwit address to legacy format Converts an existing segwit address to the legacy
     * format. &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
     *
     * @param vaultAccountId The ID of the vault account (required)
     * @param assetId The ID of the asset (required)
     * @param addressId The segwit address to translate (required)
     * @param idempotencyKey A unique identifier for the request. If the request is sent multiple
     *     times with the same idempotency key, the server will return the same response as the
     *     first request. The idempotency key is valid for 24 hours. (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;CreateAddressResponse&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<CreateAddressResponse>> createLegacyAddress(
            String vaultAccountId, String assetId, String addressId, String idempotencyKey)
            throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    createLegacyAddressRequestBuilder(
                            vaultAccountId, assetId, addressId, idempotencyKey);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "createLegacyAddress", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<CreateAddressResponse>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            CreateAddressResponse>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder createLegacyAddressRequestBuilder(
            String vaultAccountId, String assetId, String addressId, String idempotencyKey)
            throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "createLegacyAddress", "vaultAccountId", vaultAccountId);
        ValidationUtils.assertParamExistsAndNotEmpty("createLegacyAddress", "assetId", assetId);
        ValidationUtils.assertParamExistsAndNotEmpty("createLegacyAddress", "addressId", addressId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/create_legacy"
                        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
                        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()))
                        .replace("{addressId}", ApiClient.urlEncode(addressId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        if (idempotencyKey != null) {
            localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
        }
        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Bulk creation of new vault accounts Create multiple vault accounts by running an async job. -
     * The HBAR, TON, SUI, TERRA, ALGO, and DOT blockchains are not supported. - Limited to a
     * maximum of 10,000 accounts per operation. **Endpoint Permissions:** Admin, Non-Signing Admin,
     * Signer, Approver, Editor.
     *
     * @param createMultipleAccountsRequest (required)
     * @param idempotencyKey A unique identifier for the request. If the request is sent multiple
     *     times with the same idempotency key, the server will return the same response as the
     *     first request. The idempotency key is valid for 24 hours. (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;JobCreated&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<JobCreated>> createMultipleAccounts(
            CreateMultipleAccountsRequest createMultipleAccountsRequest, String idempotencyKey)
            throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    createMultipleAccountsRequestBuilder(
                            createMultipleAccountsRequest, idempotencyKey);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "createMultipleAccounts", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<JobCreated>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            JobCreated>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder createMultipleAccountsRequestBuilder(
            CreateMultipleAccountsRequest createMultipleAccountsRequest, String idempotencyKey)
            throws ApiException {
        ValidationUtils.assertParamExists(
                "createMultipleAccounts",
                "createMultipleAccountsRequest",
                createMultipleAccountsRequest);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath = "/vault/accounts/bulk";

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        if (idempotencyKey != null) {
            localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
        }
        localVarRequestBuilder.header("Content-Type", "application/json");
        localVarRequestBuilder.header("Accept", "application/json");

        try {
            byte[] localVarPostBody =
                    memberVarObjectMapper.writeValueAsBytes(createMultipleAccountsRequest);
            localVarRequestBuilder.method(
                    "POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
        } catch (IOException e) {
            throw new ApiException(e);
        }
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Bulk creation of new deposit addresses **For UTXO blockchains only.** Create multiple deposit
     * addresses by running an async job. - The target Vault account should already have a UTXO
     * asset wallet with a permanent address. - Limited to a maximum of 10,000 addresses per
     * operation. Use multiple operations for the same Vault account/permanent address if needed.
     * **Endpoint Permissions:** Admin, Non-Signing Admin.
     *
     * @param createMultipleDepositAddressesRequest (required)
     * @param idempotencyKey A unique identifier for the request. If the request is sent multiple
     *     times with the same idempotency key, the server will return the same response as the
     *     first request. The idempotency key is valid for 24 hours. (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;JobCreated&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<JobCreated>> createMultipleDepositAddresses(
            CreateMultipleDepositAddressesRequest createMultipleDepositAddressesRequest,
            String idempotencyKey)
            throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    createMultipleDepositAddressesRequestBuilder(
                            createMultipleDepositAddressesRequest, idempotencyKey);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "createMultipleDepositAddresses",
                                                    localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<JobCreated>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            JobCreated>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder createMultipleDepositAddressesRequestBuilder(
            CreateMultipleDepositAddressesRequest createMultipleDepositAddressesRequest,
            String idempotencyKey)
            throws ApiException {
        ValidationUtils.assertParamExists(
                "createMultipleDepositAddresses",
                "createMultipleDepositAddressesRequest",
                createMultipleDepositAddressesRequest);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath = "/vault/accounts/addresses/bulk";

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        if (idempotencyKey != null) {
            localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
        }
        localVarRequestBuilder.header("Content-Type", "application/json");
        localVarRequestBuilder.header("Accept", "application/json");

        try {
            byte[] localVarPostBody =
                    memberVarObjectMapper.writeValueAsBytes(createMultipleDepositAddressesRequest);
            localVarRequestBuilder.method(
                    "POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
        } catch (IOException e) {
            throw new ApiException(e);
        }
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Create a new vault account Creates a new vault account with the requested name. **Note: **
     * Vault account names should consist of ASCII characters only. Learn more about Fireblocks
     * Vault Accounts in the following
     * [guide](https://developers.fireblocks.com/reference/create-vault-account).
     * &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
     *
     * @param createVaultAccountRequest (required)
     * @param idempotencyKey A unique identifier for the request. If the request is sent multiple
     *     times with the same idempotency key, the server will return the same response as the
     *     first request. The idempotency key is valid for 24 hours. (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;VaultAccount&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<VaultAccount>> createVaultAccount(
            CreateVaultAccountRequest createVaultAccountRequest, String idempotencyKey)
            throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    createVaultAccountRequestBuilder(createVaultAccountRequest, idempotencyKey);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "createVaultAccount", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<VaultAccount>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            VaultAccount>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder createVaultAccountRequestBuilder(
            CreateVaultAccountRequest createVaultAccountRequest, String idempotencyKey)
            throws ApiException {
        ValidationUtils.assertParamExists(
                "createVaultAccount", "createVaultAccountRequest", createVaultAccountRequest);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath = "/vault/accounts";

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        if (idempotencyKey != null) {
            localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
        }
        localVarRequestBuilder.header("Content-Type", "application/json");
        localVarRequestBuilder.header("Accept", "application/json");

        try {
            byte[] localVarPostBody =
                    memberVarObjectMapper.writeValueAsBytes(createVaultAccountRequest);
            localVarRequestBuilder.method(
                    "POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
        } catch (IOException e) {
            throw new ApiException(e);
        }
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Create a new vault wallet Creates a wallet for a specific asset in a vault account. Learn
     * more about Fireblocks Vault Wallets in the following
     * [guide](https://developers.fireblocks.com/reference/create-vault-wallet). &lt;/br&gt;Endpoint
     * Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
     *
     * @param vaultAccountId The ID of the vault account to return, or &#39;default&#39; for the
     *     default vault account (required)
     * @param assetId The ID of the asset (required)
     * @param createAssetsRequest (optional)
     * @param idempotencyKey A unique identifier for the request. If the request is sent multiple
     *     times with the same idempotency key, the server will return the same response as the
     *     first request. The idempotency key is valid for 24 hours. (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;CreateVaultAssetResponse&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<CreateVaultAssetResponse>> createVaultAccountAsset(
            String vaultAccountId,
            String assetId,
            CreateAssetsRequest createAssetsRequest,
            String idempotencyKey)
            throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    createVaultAccountAssetRequestBuilder(
                            vaultAccountId, assetId, createAssetsRequest, idempotencyKey);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "createVaultAccountAsset", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<CreateVaultAssetResponse>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            CreateVaultAssetResponse>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder createVaultAccountAssetRequestBuilder(
            String vaultAccountId,
            String assetId,
            CreateAssetsRequest createAssetsRequest,
            String idempotencyKey)
            throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "createVaultAccountAsset", "vaultAccountId", vaultAccountId);
        ValidationUtils.assertParamExistsAndNotEmpty("createVaultAccountAsset", "assetId", assetId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/{assetId}"
                        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
                        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        if (idempotencyKey != null) {
            localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
        }
        localVarRequestBuilder.header("Content-Type", "application/json");
        localVarRequestBuilder.header("Accept", "application/json");

        try {
            byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(createAssetsRequest);
            localVarRequestBuilder.method(
                    "POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
        } catch (IOException e) {
            throw new ApiException(e);
        }
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Create new asset deposit address Creates a new deposit address for an asset of a vault
     * account. Should be used for UTXO or Tag/Memo based assets ONLY. Requests with account based
     * assets will fail. &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin.
     *
     * @param vaultAccountId The ID of the vault account to return (required)
     * @param assetId The ID of the asset (required)
     * @param createAddressRequest (optional)
     * @param idempotencyKey A unique identifier for the request. If the request is sent multiple
     *     times with the same idempotency key, the server will return the same response as the
     *     first request. The idempotency key is valid for 24 hours. (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;CreateAddressResponse&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<CreateAddressResponse>> createVaultAccountAssetAddress(
            String vaultAccountId,
            String assetId,
            CreateAddressRequest createAddressRequest,
            String idempotencyKey)
            throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    createVaultAccountAssetAddressRequestBuilder(
                            vaultAccountId, assetId, createAddressRequest, idempotencyKey);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "createVaultAccountAssetAddress",
                                                    localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<CreateAddressResponse>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            CreateAddressResponse>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder createVaultAccountAssetAddressRequestBuilder(
            String vaultAccountId,
            String assetId,
            CreateAddressRequest createAddressRequest,
            String idempotencyKey)
            throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "createVaultAccountAssetAddress", "vaultAccountId", vaultAccountId);
        ValidationUtils.assertParamExistsAndNotEmpty(
                "createVaultAccountAssetAddress", "assetId", assetId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/{assetId}/addresses"
                        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
                        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        if (idempotencyKey != null) {
            localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
        }
        localVarRequestBuilder.header("Content-Type", "application/json");
        localVarRequestBuilder.header("Accept", "application/json");

        try {
            byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(createAddressRequest);
            localVarRequestBuilder.method(
                    "POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
        } catch (IOException e) {
            throw new ApiException(e);
        }
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Get vault wallets (Paginated) Get all vault wallets of the vault accounts in your workspace.
     * A vault wallet is an asset in a vault account. This method allows fast traversal of all
     * account balances. &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver,
     * Editor, Viewer.
     *
     * @param totalAmountLargerThan When specified, only vault wallets with total balance greater
     *     than this amount are returned. (optional)
     * @param assetId When specified, only vault wallets with the specified ID are returned.
     *     (optional)
     * @param orderBy (optional, default to DESC)
     * @param before Fetches the next paginated response before this element. This element is a
     *     cursor and is returned at the response of the previous page. (optional)
     * @param after Fetches the next paginated response after this element. This element is a cursor
     *     and is returned at the response of the previous page. (optional)
     * @param limit The maximum number of vault wallets in a single response. The default is 200 and
     *     the maximum is 1000. (optional, default to 200)
     * @return CompletableFuture&lt;ApiResponse&lt;PaginatedAssetWalletResponse&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<PaginatedAssetWalletResponse>> getAssetWallets(
            BigDecimal totalAmountLargerThan,
            String assetId,
            String orderBy,
            String before,
            String after,
            BigDecimal limit)
            throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    getAssetWalletsRequestBuilder(
                            totalAmountLargerThan, assetId, orderBy, before, after, limit);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException("getAssetWallets", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<PaginatedAssetWalletResponse>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            PaginatedAssetWalletResponse>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder getAssetWalletsRequestBuilder(
            BigDecimal totalAmountLargerThan,
            String assetId,
            String orderBy,
            String before,
            String after,
            BigDecimal limit)
            throws ApiException {

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath = "/vault/asset_wallets";

        List<Pair> localVarQueryParams = new ArrayList<>();
        StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
        String localVarQueryParameterBaseName;
        localVarQueryParameterBaseName = "totalAmountLargerThan";
        localVarQueryParams.addAll(
                ApiClient.parameterToPairs("totalAmountLargerThan", totalAmountLargerThan));
        localVarQueryParameterBaseName = "assetId";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("assetId", assetId));
        localVarQueryParameterBaseName = "orderBy";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("orderBy", orderBy));
        localVarQueryParameterBaseName = "before";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("before", before));
        localVarQueryParameterBaseName = "after";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("after", after));
        localVarQueryParameterBaseName = "limit";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));

        if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
            StringJoiner queryJoiner = new StringJoiner("&");
            localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
            if (localVarQueryStringJoiner.length() != 0) {
                queryJoiner.add(localVarQueryStringJoiner.toString());
            }
            localVarRequestBuilder.uri(
                    URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
        } else {
            localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
        }

        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Get the job status of the bulk deposit address creation Returns the current status of (or an
     * error for) the specified deposit addresss bulk creation job. **Endpoint Permissions:** Admin,
     * Non-Signing Admin, Signer, Approver, Editor, and Viewer.
     *
     * @param jobId The ID of the job to create addresses (required)
     * @return CompletableFuture&lt;ApiResponse&lt;CreateMultipleDepositAddressesJobStatus&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<CreateMultipleDepositAddressesJobStatus>>
            getCreateMultipleDepositAddressesJobStatus(String jobId) throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    getCreateMultipleDepositAddressesJobStatusRequestBuilder(jobId);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "getCreateMultipleDepositAddressesJobStatus",
                                                    localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<
                                                    CreateMultipleDepositAddressesJobStatus>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            CreateMultipleDepositAddressesJobStatus>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder getCreateMultipleDepositAddressesJobStatusRequestBuilder(
            String jobId) throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "getCreateMultipleDepositAddressesJobStatus", "jobId", jobId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/addresses/bulk/{jobId}"
                        .replace("{jobId}", ApiClient.urlEncode(jobId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Get job status of bulk creation of new vault accounts Returns the current status of (or error
     * for) the specified vault account bulk creation job. **Endpoint Permissions:** Admin,
     * Non-Signing Admin, Signer, Approver, Editor, Viewer.
     *
     * @param jobId The ID of the job to create addresses (required)
     * @return CompletableFuture&lt;ApiResponse&lt;CreateMultipleVaultAccountsJobStatus&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<CreateMultipleVaultAccountsJobStatus>>
            getCreateMultipleVaultAccountsJobStatus(String jobId) throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    getCreateMultipleVaultAccountsJobStatusRequestBuilder(jobId);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "getCreateMultipleVaultAccountsJobStatus",
                                                    localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<CreateMultipleVaultAccountsJobStatus>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            CreateMultipleVaultAccountsJobStatus>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder getCreateMultipleVaultAccountsJobStatusRequestBuilder(String jobId)
            throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "getCreateMultipleVaultAccountsJobStatus", "jobId", jobId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/bulk/{jobId}"
                        .replace("{jobId}", ApiClient.urlEncode(jobId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Get maximum BIP44 index used Retrieves the maximum BIP44 address index and change address
     * index used for a specific asset in a vault account (BIP44 standard).
     *
     * @param vaultAccountId The ID of the vault account (required)
     * @param assetId The ID of the asset (required)
     * @return CompletableFuture&lt;ApiResponse&lt;GetMaxBipIndexUsedResponse&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<GetMaxBipIndexUsedResponse>> getMaxBipIndexUsed(
            String vaultAccountId, String assetId) throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    getMaxBipIndexUsedRequestBuilder(vaultAccountId, assetId);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "getMaxBipIndexUsed", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<GetMaxBipIndexUsedResponse>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            GetMaxBipIndexUsedResponse>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder getMaxBipIndexUsedRequestBuilder(
            String vaultAccountId, String assetId) throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "getMaxBipIndexUsed", "vaultAccountId", vaultAccountId);
        ValidationUtils.assertParamExistsAndNotEmpty("getMaxBipIndexUsed", "assetId", assetId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/{assetId}/max_bip_index_used"
                        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
                        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Get max spendable amount in a transaction **UTXO assets only.** Retrieve the maximum amount
     * of the specified asset that can be spent in a single transaction from the specified vault
     * account. **Endpoint Permissions:** Admin, Non-Signing Admin, Signer, Approver, Editor,
     * Viewer.
     *
     * @param vaultAccountId The ID of the vault account, or &#39;default&#39; for the default vault
     *     account (required)
     * @param assetId The ID of the asset (required)
     * @param manualSignging False by default. The maximum number of inputs depends if the
     *     transaction will be signed by an automated co-signer server or on a mobile device.
     *     (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;GetMaxSpendableAmountResponse&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<GetMaxSpendableAmountResponse>> getMaxSpendableAmount(
            String vaultAccountId, String assetId, Boolean manualSignging) throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    getMaxSpendableAmountRequestBuilder(vaultAccountId, assetId, manualSignging);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "getMaxSpendableAmount", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<GetMaxSpendableAmountResponse>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            GetMaxSpendableAmountResponse>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder getMaxSpendableAmountRequestBuilder(
            String vaultAccountId, String assetId, Boolean manualSignging) throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "getMaxSpendableAmount", "vaultAccountId", vaultAccountId);
        ValidationUtils.assertParamExistsAndNotEmpty("getMaxSpendableAmount", "assetId", assetId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/{assetId}/max_spendable_amount"
                        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
                        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<>();
        StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
        String localVarQueryParameterBaseName;
        localVarQueryParameterBaseName = "manualSignging";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("manualSignging", manualSignging));

        if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
            StringJoiner queryJoiner = new StringJoiner("&");
            localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
            if (localVarQueryStringJoiner.length() != 0) {
                queryJoiner.add(localVarQueryStringJoiner.toString());
            }
            localVarRequestBuilder.uri(
                    URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
        } else {
            localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
        }

        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Get vault accounts (Paginated) Gets all vault accounts in your workspace. This endpoint
     * returns a limited amount of results with a quick response time. &lt;/br&gt;Endpoint
     * Permission: Admin, Non-Signing Admin, Signer, Approver, Editor, Viewer.
     *
     * @param namePrefix (optional)
     * @param nameSuffix (optional)
     * @param minAmountThreshold Specifying minAmountThreshold will filter accounts with balances
     *     greater than this value, otherwise, it will return all accounts. The amount set in this
     *     parameter is the native asset amount and not its USD value. (optional)
     * @param assetId (optional)
     * @param orderBy (optional, default to DESC)
     * @param before (optional)
     * @param after (optional)
     * @param limit (optional, default to 200)
     * @param tagIds DEPRECATED - use includeTagIds instead (optional
     * @param includeTagIds List of tag IDs to include. Vault accounts with any of these tags will
     *     be included (optional
     * @param excludeTagIds List of tag IDs to exclude. Vault accounts with any of these tags will
     *     be filtered out (optional
     * @return CompletableFuture&lt;ApiResponse&lt;VaultAccountsPagedResponse&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<VaultAccountsPagedResponse>> getPagedVaultAccounts(
            String namePrefix,
            String nameSuffix,
            BigDecimal minAmountThreshold,
            String assetId,
            String orderBy,
            String before,
            String after,
            BigDecimal limit,
            List<UUID> tagIds,
            List<UUID> includeTagIds,
            List<UUID> excludeTagIds)
            throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    getPagedVaultAccountsRequestBuilder(
                            namePrefix,
                            nameSuffix,
                            minAmountThreshold,
                            assetId,
                            orderBy,
                            before,
                            after,
                            limit,
                            tagIds,
                            includeTagIds,
                            excludeTagIds);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "getPagedVaultAccounts", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<VaultAccountsPagedResponse>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            VaultAccountsPagedResponse>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder getPagedVaultAccountsRequestBuilder(
            String namePrefix,
            String nameSuffix,
            BigDecimal minAmountThreshold,
            String assetId,
            String orderBy,
            String before,
            String after,
            BigDecimal limit,
            List<UUID> tagIds,
            List<UUID> includeTagIds,
            List<UUID> excludeTagIds)
            throws ApiException {

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath = "/vault/accounts_paged";

        List<Pair> localVarQueryParams = new ArrayList<>();
        StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
        String localVarQueryParameterBaseName;
        localVarQueryParameterBaseName = "namePrefix";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("namePrefix", namePrefix));
        localVarQueryParameterBaseName = "nameSuffix";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("nameSuffix", nameSuffix));
        localVarQueryParameterBaseName = "minAmountThreshold";
        localVarQueryParams.addAll(
                ApiClient.parameterToPairs("minAmountThreshold", minAmountThreshold));
        localVarQueryParameterBaseName = "assetId";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("assetId", assetId));
        localVarQueryParameterBaseName = "orderBy";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("orderBy", orderBy));
        localVarQueryParameterBaseName = "before";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("before", before));
        localVarQueryParameterBaseName = "after";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("after", after));
        localVarQueryParameterBaseName = "limit";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));
        localVarQueryParameterBaseName = "tagIds";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "tagIds", tagIds));
        localVarQueryParameterBaseName = "includeTagIds";
        localVarQueryParams.addAll(
                ApiClient.parameterToPairs("multi", "includeTagIds", includeTagIds));
        localVarQueryParameterBaseName = "excludeTagIds";
        localVarQueryParams.addAll(
                ApiClient.parameterToPairs("multi", "excludeTagIds", excludeTagIds));

        if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
            StringJoiner queryJoiner = new StringJoiner("&");
            localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
            if (localVarQueryStringJoiner.length() != 0) {
                queryJoiner.add(localVarQueryStringJoiner.toString());
            }
            localVarRequestBuilder.uri(
                    URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
        } else {
            localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
        }

        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Get the public key for a derivation path Gets the public key information based on derivation
     * path and signing algorithm. &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin.
     *
     * @param derivationPath (required)
     * @param algorithm (required)
     * @param compressed (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;PublicKeyInformation&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<PublicKeyInformation>> getPublicKeyInfo(
            String derivationPath, String algorithm, Boolean compressed) throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    getPublicKeyInfoRequestBuilder(derivationPath, algorithm, compressed);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException("getPublicKeyInfo", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<PublicKeyInformation>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            PublicKeyInformation>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder getPublicKeyInfoRequestBuilder(
            String derivationPath, String algorithm, Boolean compressed) throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "getPublicKeyInfo", "derivationPath", derivationPath);
        ValidationUtils.assertParamExistsAndNotEmpty("getPublicKeyInfo", "algorithm", algorithm);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath = "/vault/public_key_info";

        List<Pair> localVarQueryParams = new ArrayList<>();
        StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
        String localVarQueryParameterBaseName;
        localVarQueryParameterBaseName = "derivationPath";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("derivationPath", derivationPath));
        localVarQueryParameterBaseName = "algorithm";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("algorithm", algorithm));
        localVarQueryParameterBaseName = "compressed";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("compressed", compressed));

        if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
            StringJoiner queryJoiner = new StringJoiner("&");
            localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
            if (localVarQueryStringJoiner.length() != 0) {
                queryJoiner.add(localVarQueryStringJoiner.toString());
            }
            localVarRequestBuilder.uri(
                    URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
        } else {
            localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
        }

        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Get an asset&#39;s public key Get the public key information for a specific asset in a vault
     * account. &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin.
     *
     * @param vaultAccountId (required)
     * @param assetId (required)
     * @param change (required)
     * @param addressIndex (required)
     * @param compressed (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;PublicKeyInformation&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<PublicKeyInformation>> getPublicKeyInfoForAddress(
            String vaultAccountId,
            String assetId,
            BigDecimal change,
            BigDecimal addressIndex,
            Boolean compressed)
            throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    getPublicKeyInfoForAddressRequestBuilder(
                            vaultAccountId, assetId, change, addressIndex, compressed);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "getPublicKeyInfoForAddress",
                                                    localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<PublicKeyInformation>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            PublicKeyInformation>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder getPublicKeyInfoForAddressRequestBuilder(
            String vaultAccountId,
            String assetId,
            BigDecimal change,
            BigDecimal addressIndex,
            Boolean compressed)
            throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "getPublicKeyInfoForAddress", "vaultAccountId", vaultAccountId);
        ValidationUtils.assertParamExistsAndNotEmpty(
                "getPublicKeyInfoForAddress", "assetId", assetId);
        ValidationUtils.assertParamExists("getPublicKeyInfoForAddress", "change", change);
        ValidationUtils.assertParamExists(
                "getPublicKeyInfoForAddress", "addressIndex", addressIndex);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/{assetId}/{change}/{addressIndex}/public_key_info"
                        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
                        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()))
                        .replace("{change}", ApiClient.urlEncode(change.toString()))
                        .replace("{addressIndex}", ApiClient.urlEncode(addressIndex.toString()));

        List<Pair> localVarQueryParams = new ArrayList<>();
        StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
        String localVarQueryParameterBaseName;
        localVarQueryParameterBaseName = "compressed";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("compressed", compressed));

        if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
            StringJoiner queryJoiner = new StringJoiner("&");
            localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
            if (localVarQueryStringJoiner.length() != 0) {
                queryJoiner.add(localVarQueryStringJoiner.toString());
            }
            localVarRequestBuilder.uri(
                    URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
        } else {
            localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
        }

        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Get UTXO unspent inputs information Returns unspent inputs information of an UTXO asset in a
     * vault account. &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver,
     * Editor, Viewer.
     *
     * @param vaultAccountId The ID of the vault account (required)
     * @param assetId The ID of the asset (required)
     * @return CompletableFuture&lt;ApiResponse&lt;List&lt;UnspentInputsResponse&gt;&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<List<UnspentInputsResponse>>> getUnspentInputs(
            String vaultAccountId, String assetId) throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    getUnspentInputsRequestBuilder(vaultAccountId, assetId);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException("getUnspentInputs", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<List<UnspentInputsResponse>>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            List<
                                                                                    UnspentInputsResponse>>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder getUnspentInputsRequestBuilder(
            String vaultAccountId, String assetId) throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "getUnspentInputs", "vaultAccountId", vaultAccountId);
        ValidationUtils.assertParamExistsAndNotEmpty("getUnspentInputs", "assetId", assetId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/{assetId}/unspent_inputs"
                        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
                        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Get a vault account by ID Get a vault account by its unique ID. &lt;/br&gt;Endpoint
     * Permission: Admin, Non-Signing Admin, Signer, Approver, Editor, Viewer.
     *
     * @param vaultAccountId The ID of the vault account (required)
     * @return CompletableFuture&lt;ApiResponse&lt;VaultAccount&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<VaultAccount>> getVaultAccount(String vaultAccountId)
            throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    getVaultAccountRequestBuilder(vaultAccountId);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException("getVaultAccount", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<VaultAccount>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            VaultAccount>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder getVaultAccountRequestBuilder(String vaultAccountId)
            throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "getVaultAccount", "vaultAccountId", vaultAccountId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}"
                        .replace(
                                "{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Get the asset balance for a vault account Returns a specific vault wallet balance information
     * for a specific asset. &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin, Signer,
     * Approver, Editor, Viewer.
     *
     * @param vaultAccountId The ID of the vault account to return (required)
     * @param assetId The ID of the asset (required)
     * @return CompletableFuture&lt;ApiResponse&lt;VaultAsset&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<VaultAsset>> getVaultAccountAsset(
            String vaultAccountId, String assetId) throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    getVaultAccountAssetRequestBuilder(vaultAccountId, assetId);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "getVaultAccountAsset", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<VaultAsset>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            VaultAsset>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder getVaultAccountAssetRequestBuilder(
            String vaultAccountId, String assetId) throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "getVaultAccountAsset", "vaultAccountId", vaultAccountId);
        ValidationUtils.assertParamExistsAndNotEmpty("getVaultAccountAsset", "assetId", assetId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/{assetId}"
                        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
                        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Get addresses (Paginated) Returns a paginated response of the addresses for a given vault
     * account and asset. &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin, Signer,
     * Approver, Editor, Viewer.
     *
     * @param vaultAccountId The ID of the vault account to return (required)
     * @param assetId The ID of the asset (required)
     * @param limit (optional)
     * @param before (optional)
     * @param after (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;PaginatedAddressResponse&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<PaginatedAddressResponse>>
            getVaultAccountAssetAddressesPaginated(
                    String vaultAccountId,
                    String assetId,
                    BigDecimal limit,
                    String before,
                    String after)
                    throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    getVaultAccountAssetAddressesPaginatedRequestBuilder(
                            vaultAccountId, assetId, limit, before, after);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "getVaultAccountAssetAddressesPaginated",
                                                    localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<PaginatedAddressResponse>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            PaginatedAddressResponse>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder getVaultAccountAssetAddressesPaginatedRequestBuilder(
            String vaultAccountId, String assetId, BigDecimal limit, String before, String after)
            throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "getVaultAccountAssetAddressesPaginated", "vaultAccountId", vaultAccountId);
        ValidationUtils.assertParamExistsAndNotEmpty(
                "getVaultAccountAssetAddressesPaginated", "assetId", assetId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated"
                        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
                        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<>();
        StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
        String localVarQueryParameterBaseName;
        localVarQueryParameterBaseName = "limit";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));
        localVarQueryParameterBaseName = "before";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("before", before));
        localVarQueryParameterBaseName = "after";
        localVarQueryParams.addAll(ApiClient.parameterToPairs("after", after));

        if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
            StringJoiner queryJoiner = new StringJoiner("&");
            localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
            if (localVarQueryStringJoiner.length() != 0) {
                queryJoiner.add(localVarQueryStringJoiner.toString());
            }
            localVarRequestBuilder.uri(
                    URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
        } else {
            localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
        }

        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Get asset balance for chosen assets Gets the assets amount summary for all accounts or
     * filtered accounts. &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin, Signer,
     * Approver, Editor, Viewer.
     *
     * @param accountNamePrefix (optional)
     * @param accountNameSuffix (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;List&lt;VaultAsset&gt;&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<List<VaultAsset>>> getVaultAssets(
            String accountNamePrefix, String accountNameSuffix) throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    getVaultAssetsRequestBuilder(accountNamePrefix, accountNameSuffix);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException("getVaultAssets", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<List<VaultAsset>>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            List<
                                                                                    VaultAsset>>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder getVaultAssetsRequestBuilder(
            String accountNamePrefix, String accountNameSuffix) throws ApiException {

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath = "/vault/assets";

        List<Pair> localVarQueryParams = new ArrayList<>();
        StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
        String localVarQueryParameterBaseName;
        localVarQueryParameterBaseName = "accountNamePrefix";
        localVarQueryParams.addAll(
                ApiClient.parameterToPairs("accountNamePrefix", accountNamePrefix));
        localVarQueryParameterBaseName = "accountNameSuffix";
        localVarQueryParams.addAll(
                ApiClient.parameterToPairs("accountNameSuffix", accountNameSuffix));

        if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
            StringJoiner queryJoiner = new StringJoiner("&");
            localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
            if (localVarQueryStringJoiner.length() != 0) {
                queryJoiner.add(localVarQueryStringJoiner.toString());
            }
            localVarRequestBuilder.uri(
                    URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
        } else {
            localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
        }

        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Get vault balance by an asset Get the total balance of an asset across all the vault
     * accounts. &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor,
     * Viewer.
     *
     * @param assetId (required)
     * @return CompletableFuture&lt;ApiResponse&lt;VaultAsset&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<VaultAsset>> getVaultBalanceByAsset(String assetId)
            throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    getVaultBalanceByAssetRequestBuilder(assetId);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "getVaultBalanceByAsset", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<VaultAsset>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            VaultAsset>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder getVaultBalanceByAssetRequestBuilder(String assetId)
            throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty("getVaultBalanceByAsset", "assetId", assetId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/assets/{assetId}"
                        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Hide a vault account in the console Hides the requested vault account from the web console
     * view. This operation is required when creating thousands of vault accounts to serve your
     * end-users. Used for preventing the web console to be swamped with too much vault accounts.
     * Learn more in the following
     * [guide](https://developers.fireblocks.com/docs/create-direct-custody-wallets#hiding-vault-accounts).
     * NOTE: Hiding the vault account from the web console will also hide all the related
     * transactions to/from this vault. &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin,
     * Signer, Approver, Editor.
     *
     * @param vaultAccountId The vault account to hide (required)
     * @param idempotencyKey A unique identifier for the request. If the request is sent multiple
     *     times with the same idempotency key, the server will return the same response as the
     *     first request. The idempotency key is valid for 24 hours. (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;VaultActionStatus&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<VaultActionStatus>> hideVaultAccount(
            String vaultAccountId, String idempotencyKey) throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    hideVaultAccountRequestBuilder(vaultAccountId, idempotencyKey);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException("hideVaultAccount", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<VaultActionStatus>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            VaultActionStatus>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder hideVaultAccountRequestBuilder(
            String vaultAccountId, String idempotencyKey) throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "hideVaultAccount", "vaultAccountId", vaultAccountId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/hide"
                        .replace(
                                "{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        if (idempotencyKey != null) {
            localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
        }
        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Assign AML customer reference ID Sets an AML/KYT customer reference ID for a specific
     * address. &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin.
     *
     * @param setCustomerRefIdForAddressRequest (required)
     * @param vaultAccountId The ID of the vault account (required)
     * @param assetId The ID of the asset (required)
     * @param addressId The address for which to add a description. For XRP, use
     *     &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address (required)
     * @param idempotencyKey A unique identifier for the request. If the request is sent multiple
     *     times with the same idempotency key, the server will return the same response as the
     *     first request. The idempotency key is valid for 24 hours. (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;VaultActionStatus&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<VaultActionStatus>> setCustomerRefIdForAddress(
            SetCustomerRefIdForAddressRequest setCustomerRefIdForAddressRequest,
            String vaultAccountId,
            String assetId,
            String addressId,
            String idempotencyKey)
            throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    setCustomerRefIdForAddressRequestBuilder(
                            setCustomerRefIdForAddressRequest,
                            vaultAccountId,
                            assetId,
                            addressId,
                            idempotencyKey);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "setCustomerRefIdForAddress",
                                                    localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<VaultActionStatus>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            VaultActionStatus>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder setCustomerRefIdForAddressRequestBuilder(
            SetCustomerRefIdForAddressRequest setCustomerRefIdForAddressRequest,
            String vaultAccountId,
            String assetId,
            String addressId,
            String idempotencyKey)
            throws ApiException {
        ValidationUtils.assertParamExists(
                "setCustomerRefIdForAddress",
                "setCustomerRefIdForAddressRequest",
                setCustomerRefIdForAddressRequest);
        ValidationUtils.assertParamExistsAndNotEmpty(
                "setCustomerRefIdForAddress", "vaultAccountId", vaultAccountId);
        ValidationUtils.assertParamExistsAndNotEmpty(
                "setCustomerRefIdForAddress", "assetId", assetId);
        ValidationUtils.assertParamExistsAndNotEmpty(
                "setCustomerRefIdForAddress", "addressId", addressId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/set_customer_ref_id"
                        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
                        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()))
                        .replace("{addressId}", ApiClient.urlEncode(addressId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        if (idempotencyKey != null) {
            localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
        }
        localVarRequestBuilder.header("Content-Type", "application/json");
        localVarRequestBuilder.header("Accept", "application/json");

        try {
            byte[] localVarPostBody =
                    memberVarObjectMapper.writeValueAsBytes(setCustomerRefIdForAddressRequest);
            localVarRequestBuilder.method(
                    "POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
        } catch (IOException e) {
            throw new ApiException(e);
        }
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Set auto fueling to on or off Toggles the auto fueling property of the vault account to
     * enabled or disabled. Vault Accounts with &#39;autoFuel&#x3D;true&#39; are monitored and auto
     * fueled by the Fireblocks Gas Station. Learn more about the Fireblocks Gas Station in the
     * following [guide](https://developers.fireblocks.com/docs/work-with-gas-station).
     * &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
     *
     * @param setAutoFuelRequest (required)
     * @param vaultAccountId The vault account ID (required)
     * @param idempotencyKey A unique identifier for the request. If the request is sent multiple
     *     times with the same idempotency key, the server will return the same response as the
     *     first request. The idempotency key is valid for 24 hours. (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;VaultActionStatus&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<VaultActionStatus>> setVaultAccountAutoFuel(
            SetAutoFuelRequest setAutoFuelRequest, String vaultAccountId, String idempotencyKey)
            throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    setVaultAccountAutoFuelRequestBuilder(
                            setAutoFuelRequest, vaultAccountId, idempotencyKey);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "setVaultAccountAutoFuel", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<VaultActionStatus>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            VaultActionStatus>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder setVaultAccountAutoFuelRequestBuilder(
            SetAutoFuelRequest setAutoFuelRequest, String vaultAccountId, String idempotencyKey)
            throws ApiException {
        ValidationUtils.assertParamExists(
                "setVaultAccountAutoFuel", "setAutoFuelRequest", setAutoFuelRequest);
        ValidationUtils.assertParamExistsAndNotEmpty(
                "setVaultAccountAutoFuel", "vaultAccountId", vaultAccountId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/set_auto_fuel"
                        .replace(
                                "{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        if (idempotencyKey != null) {
            localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
        }
        localVarRequestBuilder.header("Content-Type", "application/json");
        localVarRequestBuilder.header("Accept", "application/json");

        try {
            byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(setAutoFuelRequest);
            localVarRequestBuilder.method(
                    "POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
        } catch (IOException e) {
            throw new ApiException(e);
        }
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Set an AML/KYT ID for a vault account Assigns an AML/KYT customer reference ID for the vault
     * account. Learn more about Fireblocks AML management in the following
     * [guide](https://developers.fireblocks.com/docs/define-aml-policies). &lt;/br&gt;Endpoint
     * Permission: Admin, Non-Signing Admin.
     *
     * @param setCustomerRefIdRequest (required)
     * @param vaultAccountId The vault account ID (required)
     * @param idempotencyKey A unique identifier for the request. If the request is sent multiple
     *     times with the same idempotency key, the server will return the same response as the
     *     first request. The idempotency key is valid for 24 hours. (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;VaultActionStatus&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<VaultActionStatus>> setVaultAccountCustomerRefId(
            SetCustomerRefIdRequest setCustomerRefIdRequest,
            String vaultAccountId,
            String idempotencyKey)
            throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    setVaultAccountCustomerRefIdRequestBuilder(
                            setCustomerRefIdRequest, vaultAccountId, idempotencyKey);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "setVaultAccountCustomerRefId",
                                                    localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<VaultActionStatus>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            VaultActionStatus>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder setVaultAccountCustomerRefIdRequestBuilder(
            SetCustomerRefIdRequest setCustomerRefIdRequest,
            String vaultAccountId,
            String idempotencyKey)
            throws ApiException {
        ValidationUtils.assertParamExists(
                "setVaultAccountCustomerRefId", "setCustomerRefIdRequest", setCustomerRefIdRequest);
        ValidationUtils.assertParamExistsAndNotEmpty(
                "setVaultAccountCustomerRefId", "vaultAccountId", vaultAccountId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/set_customer_ref_id"
                        .replace(
                                "{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        if (idempotencyKey != null) {
            localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
        }
        localVarRequestBuilder.header("Content-Type", "application/json");
        localVarRequestBuilder.header("Accept", "application/json");

        try {
            byte[] localVarPostBody =
                    memberVarObjectMapper.writeValueAsBytes(setCustomerRefIdRequest);
            localVarRequestBuilder.method(
                    "POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
        } catch (IOException e) {
            throw new ApiException(e);
        }
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Unhide a vault account in the console Makes a hidden vault account visible in web console
     * view. &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
     *
     * @param vaultAccountId The vault account to unhide (required)
     * @param idempotencyKey A unique identifier for the request. If the request is sent multiple
     *     times with the same idempotency key, the server will return the same response as the
     *     first request. The idempotency key is valid for 24 hours. (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;VaultActionStatus&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<VaultActionStatus>> unhideVaultAccount(
            String vaultAccountId, String idempotencyKey) throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    unhideVaultAccountRequestBuilder(vaultAccountId, idempotencyKey);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "unhideVaultAccount", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<VaultActionStatus>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            VaultActionStatus>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder unhideVaultAccountRequestBuilder(
            String vaultAccountId, String idempotencyKey) throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "unhideVaultAccount", "vaultAccountId", vaultAccountId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/unhide"
                        .replace(
                                "{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        if (idempotencyKey != null) {
            localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
        }
        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Rename a vault account Renames the requested vault account. &lt;/br&gt;Endpoint Permission:
     * Admin, Non-Signing Admin, Signer, Approver.
     *
     * @param updateVaultAccountRequest (required)
     * @param vaultAccountId The ID of the vault account to edit (required)
     * @param idempotencyKey A unique identifier for the request. If the request is sent multiple
     *     times with the same idempotency key, the server will return the same response as the
     *     first request. The idempotency key is valid for 24 hours. (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;RenameVaultAccountResponse&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<RenameVaultAccountResponse>> updateVaultAccount(
            UpdateVaultAccountRequest updateVaultAccountRequest,
            String vaultAccountId,
            String idempotencyKey)
            throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    updateVaultAccountRequestBuilder(
                            updateVaultAccountRequest, vaultAccountId, idempotencyKey);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "updateVaultAccount", localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<RenameVaultAccountResponse>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            RenameVaultAccountResponse>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder updateVaultAccountRequestBuilder(
            UpdateVaultAccountRequest updateVaultAccountRequest,
            String vaultAccountId,
            String idempotencyKey)
            throws ApiException {
        ValidationUtils.assertParamExists(
                "updateVaultAccount", "updateVaultAccountRequest", updateVaultAccountRequest);
        ValidationUtils.assertParamExistsAndNotEmpty(
                "updateVaultAccount", "vaultAccountId", vaultAccountId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}"
                        .replace(
                                "{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        if (idempotencyKey != null) {
            localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
        }
        localVarRequestBuilder.header("Content-Type", "application/json");
        localVarRequestBuilder.header("Accept", "application/json");

        try {
            byte[] localVarPostBody =
                    memberVarObjectMapper.writeValueAsBytes(updateVaultAccountRequest);
            localVarRequestBuilder.method(
                    "PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
        } catch (IOException e) {
            throw new ApiException(e);
        }
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Update address description Updates the description of an existing address of an asset in a
     * vault account. &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver,
     * Editor.
     *
     * @param vaultAccountId The ID of the vault account (required)
     * @param assetId The ID of the asset (required)
     * @param addressId The address for which to add a description. For XRP, use
     *     &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address (required)
     * @param updateVaultAccountAssetAddressRequest (optional)
     * @param idempotencyKey A unique identifier for the request. If the request is sent multiple
     *     times with the same idempotency key, the server will return the same response as the
     *     first request. The idempotency key is valid for 24 hours. (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;VaultActionStatus&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<VaultActionStatus>> updateVaultAccountAssetAddress(
            String vaultAccountId,
            String assetId,
            String addressId,
            UpdateVaultAccountAssetAddressRequest updateVaultAccountAssetAddressRequest,
            String idempotencyKey)
            throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    updateVaultAccountAssetAddressRequestBuilder(
                            vaultAccountId,
                            assetId,
                            addressId,
                            updateVaultAccountAssetAddressRequest,
                            idempotencyKey);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "updateVaultAccountAssetAddress",
                                                    localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<VaultActionStatus>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            VaultActionStatus>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder updateVaultAccountAssetAddressRequestBuilder(
            String vaultAccountId,
            String assetId,
            String addressId,
            UpdateVaultAccountAssetAddressRequest updateVaultAccountAssetAddressRequest,
            String idempotencyKey)
            throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "updateVaultAccountAssetAddress", "vaultAccountId", vaultAccountId);
        ValidationUtils.assertParamExistsAndNotEmpty(
                "updateVaultAccountAssetAddress", "assetId", assetId);
        ValidationUtils.assertParamExistsAndNotEmpty(
                "updateVaultAccountAssetAddress", "addressId", addressId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}"
                        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
                        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()))
                        .replace("{addressId}", ApiClient.urlEncode(addressId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        if (idempotencyKey != null) {
            localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
        }
        localVarRequestBuilder.header("Content-Type", "application/json");
        localVarRequestBuilder.header("Accept", "application/json");

        try {
            byte[] localVarPostBody =
                    memberVarObjectMapper.writeValueAsBytes(updateVaultAccountAssetAddressRequest);
            localVarRequestBuilder.method(
                    "PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
        } catch (IOException e) {
            throw new ApiException(e);
        }
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
    /**
     * Refresh asset balance data Updates the balance of a specific asset in a vault account. This
     * API endpoint is subject to a strict rate limit. Should be used by clients in very specific
     * scenarios. &lt;/br&gt;Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver,
     * Editor.
     *
     * @param vaultAccountId The ID of the vault account to return (required)
     * @param assetId The ID of the asset (required)
     * @param idempotencyKey A unique identifier for the request. If the request is sent multiple
     *     times with the same idempotency key, the server will return the same response as the
     *     first request. The idempotency key is valid for 24 hours. (optional)
     * @return CompletableFuture&lt;ApiResponse&lt;VaultAsset&gt;&gt;
     * @throws ApiException if fails to make API call
     */
    public CompletableFuture<ApiResponse<VaultAsset>> updateVaultAccountAssetBalance(
            String vaultAccountId, String assetId, String idempotencyKey) throws ApiException {
        try {
            HttpRequest.Builder localVarRequestBuilder =
                    updateVaultAccountAssetBalanceRequestBuilder(
                            vaultAccountId, assetId, idempotencyKey);
            return memberVarHttpClient
                    .sendAsync(localVarRequestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                    .thenComposeAsync(
                            localVarResponse -> {
                                if (memberVarAsyncResponseInterceptor != null) {
                                    memberVarAsyncResponseInterceptor.accept(localVarResponse);
                                }
                                if (localVarResponse.statusCode() / 100 != 2) {
                                    return CompletableFuture.failedFuture(
                                            getApiException(
                                                    "updateVaultAccountAssetBalance",
                                                    localVarResponse));
                                }
                                try {
                                    String responseBody = localVarResponse.body();
                                    return CompletableFuture.completedFuture(
                                            new ApiResponse<VaultAsset>(
                                                    localVarResponse.statusCode(),
                                                    localVarResponse.headers().map(),
                                                    responseBody == null || responseBody.isBlank()
                                                            ? null
                                                            : memberVarObjectMapper.readValue(
                                                                    responseBody,
                                                                    new TypeReference<
                                                                            VaultAsset>() {})));
                                } catch (IOException e) {
                                    return CompletableFuture.failedFuture(new ApiException(e));
                                }
                            });
        } catch (ApiException e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private HttpRequest.Builder updateVaultAccountAssetBalanceRequestBuilder(
            String vaultAccountId, String assetId, String idempotencyKey) throws ApiException {
        ValidationUtils.assertParamExistsAndNotEmpty(
                "updateVaultAccountAssetBalance", "vaultAccountId", vaultAccountId);
        ValidationUtils.assertParamExistsAndNotEmpty(
                "updateVaultAccountAssetBalance", "assetId", assetId);

        HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

        String localVarPath =
                "/vault/accounts/{vaultAccountId}/{assetId}/balance"
                        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
                        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

        localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

        if (idempotencyKey != null) {
            localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
        }
        localVarRequestBuilder.header("Accept", "application/json");

        localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
        if (memberVarReadTimeout != null) {
            localVarRequestBuilder.timeout(memberVarReadTimeout);
        }
        if (memberVarInterceptor != null) {
            memberVarInterceptor.accept(localVarRequestBuilder);
        }
        return localVarRequestBuilder;
    }
}
