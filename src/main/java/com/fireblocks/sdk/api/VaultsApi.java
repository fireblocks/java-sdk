/*
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.fireblocks.sdk.api;

import com.fireblocks.sdk.ApiClient;
import com.fireblocks.sdk.ApiException;
import com.fireblocks.sdk.ApiResponse;
import com.fireblocks.sdk.Pair;

import java.math.BigDecimal;
import com.fireblocks.sdk.model.CreateAddressRequest;
import com.fireblocks.sdk.model.CreateAddressResponse;
import com.fireblocks.sdk.model.CreateAssetsRequest;
import com.fireblocks.sdk.model.CreateMultipleAccountsRequest;
import com.fireblocks.sdk.model.CreateVaultAccountRequest;
import com.fireblocks.sdk.model.CreateVaultAssetResponse;
import com.fireblocks.sdk.model.ErrorSchema;
import com.fireblocks.sdk.model.GetMaxSpendableAmountResponse;
import com.fireblocks.sdk.model.JobCreated;
import com.fireblocks.sdk.model.PaginatedAddressResponse;
import com.fireblocks.sdk.model.PaginatedAssetWalletResponse;
import com.fireblocks.sdk.model.PublicKeyInformation;
import com.fireblocks.sdk.model.RenameVaultAccountResponse;
import com.fireblocks.sdk.model.SetAutoFuelRequest;
import com.fireblocks.sdk.model.SetCustomerRefIdForAddressRequest;
import com.fireblocks.sdk.model.SetCustomerRefIdRequest;
import com.fireblocks.sdk.model.UnspentInputsResponse;
import com.fireblocks.sdk.model.UpdateVaultAccountAssetAddressRequest;
import com.fireblocks.sdk.model.UpdateVaultAccountRequest;
import com.fireblocks.sdk.model.VaultAccount;
import com.fireblocks.sdk.model.VaultAccountsPagedResponse;
import com.fireblocks.sdk.model.VaultActionStatus;
import com.fireblocks.sdk.model.VaultAsset;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

import java.util.concurrent.CompletableFuture;

@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class VaultsApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public VaultsApi() {
    this(new ApiClient());
  }

  public VaultsApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  private ApiException getApiException(String operationId, HttpResponse<String> response) {
    String message = formatExceptionMessage(operationId, response.statusCode(), response.body());
    return new ApiException(response.statusCode(), message, response.headers(), response.body());
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Activate a wallet in a vault account
   * Initiates activation for a wallet in a vault account.
   * @param vaultAccountId The ID of the vault account to return, or &#39;default&#39; for the default vault account (required)
   * @param assetId The ID of the asset (required)
   * @param idempotencyKey A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;CreateVaultAssetResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CreateVaultAssetResponse>> activateAssetForVaultAccount(String vaultAccountId, String assetId, String idempotencyKey) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = activateAssetForVaultAccountRequestBuilder(vaultAccountId, assetId, idempotencyKey);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("activateAssetForVaultAccount", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<CreateVaultAssetResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<CreateVaultAssetResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder activateAssetForVaultAccountRequestBuilder(String vaultAccountId, String assetId, String idempotencyKey) throws ApiException {
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling activateAssetForVaultAccount");
    }
    // verify the required parameter 'assetId' is set
    if (assetId == null) {
      throw new ApiException(400, "Missing the required parameter 'assetId' when calling activateAssetForVaultAccount");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/activate"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (idempotencyKey != null) {
      localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Convert a segwit address to legacy format
   * Converts an existing segwit address to the legacy format.
   * @param vaultAccountId The ID of the vault account (required)
   * @param assetId The ID of the asset (required)
   * @param addressId The segwit address to translate (required)
   * @param idempotencyKey A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;CreateAddressResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CreateAddressResponse>> createLegacyAddress(String vaultAccountId, String assetId, String addressId, String idempotencyKey) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = createLegacyAddressRequestBuilder(vaultAccountId, assetId, addressId, idempotencyKey);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("createLegacyAddress", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<CreateAddressResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<CreateAddressResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder createLegacyAddressRequestBuilder(String vaultAccountId, String assetId, String addressId, String idempotencyKey) throws ApiException {
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling createLegacyAddress");
    }
    // verify the required parameter 'assetId' is set
    if (assetId == null) {
      throw new ApiException(400, "Missing the required parameter 'assetId' when calling createLegacyAddress");
    }
    // verify the required parameter 'addressId' is set
    if (addressId == null) {
      throw new ApiException(400, "Missing the required parameter 'addressId' when calling createLegacyAddress");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/create_legacy"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()))
        .replace("{addressId}", ApiClient.urlEncode(addressId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (idempotencyKey != null) {
      localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Bulk creation of new vault accounts
   * Create multiple vault accounts by running an async job. &lt;/br&gt; **Note**: - These endpoints are currently in beta and might be subject to changes. - We limit accounts to 10k per operation and 200k per customer during beta testing. 
   * @param createMultipleAccountsRequest  (required)
   * @param idempotencyKey A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;JobCreated&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<JobCreated>> createMultipleAccounts(CreateMultipleAccountsRequest createMultipleAccountsRequest, String idempotencyKey) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = createMultipleAccountsRequestBuilder(createMultipleAccountsRequest, idempotencyKey);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("createMultipleAccounts", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<JobCreated>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<JobCreated>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder createMultipleAccountsRequestBuilder(CreateMultipleAccountsRequest createMultipleAccountsRequest, String idempotencyKey) throws ApiException {
    // verify the required parameter 'createMultipleAccountsRequest' is set
    if (createMultipleAccountsRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createMultipleAccountsRequest' when calling createMultipleAccounts");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/bulk";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (idempotencyKey != null) {
      localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(createMultipleAccountsRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Create a new vault account
   * Creates a new vault account with the requested name.
   * @param createVaultAccountRequest  (required)
   * @param idempotencyKey A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;VaultAccount&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<VaultAccount>> createVaultAccount(CreateVaultAccountRequest createVaultAccountRequest, String idempotencyKey) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = createVaultAccountRequestBuilder(createVaultAccountRequest, idempotencyKey);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("createVaultAccount", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<VaultAccount>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<VaultAccount>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder createVaultAccountRequestBuilder(CreateVaultAccountRequest createVaultAccountRequest, String idempotencyKey) throws ApiException {
    // verify the required parameter 'createVaultAccountRequest' is set
    if (createVaultAccountRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createVaultAccountRequest' when calling createVaultAccount");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (idempotencyKey != null) {
      localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(createVaultAccountRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Create a new wallet
   * Creates a wallet for a specific asset in a vault account.
   * @param vaultAccountId The ID of the vault account to return, or &#39;default&#39; for the default vault account (required)
   * @param assetId The ID of the asset (required)
   * @param createAssetsRequest  (optional)
   * @param idempotencyKey A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;CreateVaultAssetResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CreateVaultAssetResponse>> createVaultAccountAsset(String vaultAccountId, String assetId, CreateAssetsRequest createAssetsRequest, String idempotencyKey) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = createVaultAccountAssetRequestBuilder(vaultAccountId, assetId, createAssetsRequest, idempotencyKey);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("createVaultAccountAsset", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<CreateVaultAssetResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<CreateVaultAssetResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder createVaultAccountAssetRequestBuilder(String vaultAccountId, String assetId, CreateAssetsRequest createAssetsRequest, String idempotencyKey) throws ApiException {
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling createVaultAccountAsset");
    }
    // verify the required parameter 'assetId' is set
    if (assetId == null) {
      throw new ApiException(400, "Missing the required parameter 'assetId' when calling createVaultAccountAsset");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (idempotencyKey != null) {
      localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(createAssetsRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Create new asset deposit address
   * Creates a new deposit address for an asset of a vault account.
   * @param vaultAccountId The ID of the vault account to return (required)
   * @param assetId The ID of the asset (required)
   * @param createAddressRequest  (optional)
   * @param idempotencyKey A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;CreateAddressResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CreateAddressResponse>> createVaultAccountAssetAddress(String vaultAccountId, String assetId, CreateAddressRequest createAddressRequest, String idempotencyKey) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = createVaultAccountAssetAddressRequestBuilder(vaultAccountId, assetId, createAddressRequest, idempotencyKey);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("createVaultAccountAssetAddress", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<CreateAddressResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<CreateAddressResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder createVaultAccountAssetAddressRequestBuilder(String vaultAccountId, String assetId, CreateAddressRequest createAddressRequest, String idempotencyKey) throws ApiException {
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling createVaultAccountAssetAddress");
    }
    // verify the required parameter 'assetId' is set
    if (assetId == null) {
      throw new ApiException(400, "Missing the required parameter 'assetId' when calling createVaultAccountAssetAddress");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/addresses"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (idempotencyKey != null) {
      localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(createAddressRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * List asset wallets (Paginated)
   * Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances. 
   * @param totalAmountLargerThan When specified, only asset wallets with total balance larger than this amount are returned. (optional)
   * @param assetId When specified, only asset wallets cross vault accounts that have this asset ID are returned. (optional)
   * @param orderBy  (optional, default to DESC)
   * @param before Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page. (optional)
   * @param after Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page. (optional)
   * @param limit The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000. (optional, default to 200)
   * @return CompletableFuture&lt;ApiResponse&lt;PaginatedAssetWalletResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<PaginatedAssetWalletResponse>> getAssetWallets(BigDecimal totalAmountLargerThan, String assetId, String orderBy, String before, String after, BigDecimal limit) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getAssetWalletsRequestBuilder(totalAmountLargerThan, assetId, orderBy, before, after, limit);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getAssetWallets", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<PaginatedAssetWalletResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<PaginatedAssetWalletResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getAssetWalletsRequestBuilder(BigDecimal totalAmountLargerThan, String assetId, String orderBy, String before, String after, BigDecimal limit) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/asset_wallets";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "totalAmountLargerThan";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("totalAmountLargerThan", totalAmountLargerThan));
    localVarQueryParameterBaseName = "assetId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("assetId", assetId));
    localVarQueryParameterBaseName = "orderBy";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("orderBy", orderBy));
    localVarQueryParameterBaseName = "before";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("before", before));
    localVarQueryParameterBaseName = "after";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("after", after));
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Get the maximum spendable amount in a single transaction.
   * Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.
   * @param vaultAccountId The ID of the vault account, or &#39;default&#39; for the default vault account (required)
   * @param assetId The ID of the asset (required)
   * @param manualSignging False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;GetMaxSpendableAmountResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<GetMaxSpendableAmountResponse>> getMaxSpendableAmount(String vaultAccountId, String assetId, Boolean manualSignging) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getMaxSpendableAmountRequestBuilder(vaultAccountId, assetId, manualSignging);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getMaxSpendableAmount", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<GetMaxSpendableAmountResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<GetMaxSpendableAmountResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getMaxSpendableAmountRequestBuilder(String vaultAccountId, String assetId, Boolean manualSignging) throws ApiException {
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling getMaxSpendableAmount");
    }
    // verify the required parameter 'assetId' is set
    if (assetId == null) {
      throw new ApiException(400, "Missing the required parameter 'assetId' when calling getMaxSpendableAmount");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/max_spendable_amount"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "manualSignging";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("manualSignging", manualSignging));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * List vault accounts (Paginated)
   * Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.
   * @param namePrefix  (optional)
   * @param nameSuffix  (optional)
   * @param minAmountThreshold Specifying minAmountThreshold will filter accounts with balances greater than this value, otherwise, it will return all accounts. (optional)
   * @param assetId  (optional)
   * @param orderBy  (optional, default to DESC)
   * @param before  (optional)
   * @param after  (optional)
   * @param limit  (optional, default to 200)
   * @return CompletableFuture&lt;ApiResponse&lt;VaultAccountsPagedResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<VaultAccountsPagedResponse>> getPagedVaultAccounts(String namePrefix, String nameSuffix, BigDecimal minAmountThreshold, String assetId, String orderBy, String before, String after, BigDecimal limit) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getPagedVaultAccountsRequestBuilder(namePrefix, nameSuffix, minAmountThreshold, assetId, orderBy, before, after, limit);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getPagedVaultAccounts", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<VaultAccountsPagedResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<VaultAccountsPagedResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getPagedVaultAccountsRequestBuilder(String namePrefix, String nameSuffix, BigDecimal minAmountThreshold, String assetId, String orderBy, String before, String after, BigDecimal limit) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts_paged";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "namePrefix";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("namePrefix", namePrefix));
    localVarQueryParameterBaseName = "nameSuffix";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("nameSuffix", nameSuffix));
    localVarQueryParameterBaseName = "minAmountThreshold";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("minAmountThreshold", minAmountThreshold));
    localVarQueryParameterBaseName = "assetId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("assetId", assetId));
    localVarQueryParameterBaseName = "orderBy";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("orderBy", orderBy));
    localVarQueryParameterBaseName = "before";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("before", before));
    localVarQueryParameterBaseName = "after";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("after", after));
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Get the public key information
   * Gets the public key information based on derivation path and signing algorithm.
   * @param derivationPath  (required)
   * @param algorithm  (required)
   * @param compressed  (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;PublicKeyInformation&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<PublicKeyInformation>> getPublicKeyInfo(String derivationPath, String algorithm, Boolean compressed) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getPublicKeyInfoRequestBuilder(derivationPath, algorithm, compressed);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getPublicKeyInfo", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<PublicKeyInformation>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<PublicKeyInformation>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getPublicKeyInfoRequestBuilder(String derivationPath, String algorithm, Boolean compressed) throws ApiException {
    // verify the required parameter 'derivationPath' is set
    if (derivationPath == null) {
      throw new ApiException(400, "Missing the required parameter 'derivationPath' when calling getPublicKeyInfo");
    }
    // verify the required parameter 'algorithm' is set
    if (algorithm == null) {
      throw new ApiException(400, "Missing the required parameter 'algorithm' when calling getPublicKeyInfo");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/public_key_info";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "derivationPath";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("derivationPath", derivationPath));
    localVarQueryParameterBaseName = "algorithm";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("algorithm", algorithm));
    localVarQueryParameterBaseName = "compressed";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("compressed", compressed));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Get the public key for a vault account
   * Gets the public key information for the vault account.
   * @param vaultAccountId  (required)
   * @param assetId  (required)
   * @param change  (required)
   * @param addressIndex  (required)
   * @param compressed  (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;PublicKeyInformation&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<PublicKeyInformation>> getPublicKeyInfoForAddress(String vaultAccountId, String assetId, BigDecimal change, BigDecimal addressIndex, Boolean compressed) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getPublicKeyInfoForAddressRequestBuilder(vaultAccountId, assetId, change, addressIndex, compressed);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getPublicKeyInfoForAddress", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<PublicKeyInformation>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<PublicKeyInformation>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getPublicKeyInfoForAddressRequestBuilder(String vaultAccountId, String assetId, BigDecimal change, BigDecimal addressIndex, Boolean compressed) throws ApiException {
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling getPublicKeyInfoForAddress");
    }
    // verify the required parameter 'assetId' is set
    if (assetId == null) {
      throw new ApiException(400, "Missing the required parameter 'assetId' when calling getPublicKeyInfoForAddress");
    }
    // verify the required parameter 'change' is set
    if (change == null) {
      throw new ApiException(400, "Missing the required parameter 'change' when calling getPublicKeyInfoForAddress");
    }
    // verify the required parameter 'addressIndex' is set
    if (addressIndex == null) {
      throw new ApiException(400, "Missing the required parameter 'addressIndex' when calling getPublicKeyInfoForAddress");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/{change}/{addressIndex}/public_key_info"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()))
        .replace("{change}", ApiClient.urlEncode(change.toString()))
        .replace("{addressIndex}", ApiClient.urlEncode(addressIndex.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "compressed";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("compressed", compressed));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Get UTXO unspent inputs information
   * Returns unspent inputs information of an asset in a vault account.
   * @param vaultAccountId The ID of the vault account (required)
   * @param assetId The ID of the asset (required)
   * @return CompletableFuture&lt;ApiResponse&lt;List&lt;UnspentInputsResponse&gt;&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<List<UnspentInputsResponse>>> getUnspentInputs(String vaultAccountId, String assetId) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getUnspentInputsRequestBuilder(vaultAccountId, assetId);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getUnspentInputs", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<List<UnspentInputsResponse>>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<List<UnspentInputsResponse>>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getUnspentInputsRequestBuilder(String vaultAccountId, String assetId) throws ApiException {
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling getUnspentInputs");
    }
    // verify the required parameter 'assetId' is set
    if (assetId == null) {
      throw new ApiException(400, "Missing the required parameter 'assetId' when calling getUnspentInputs");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/unspent_inputs"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Find a vault account by ID
   * Returns the requested vault account.
   * @param vaultAccountId The ID of the vault account to return type: string (required)
   * @return CompletableFuture&lt;ApiResponse&lt;VaultAccount&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<VaultAccount>> getVaultAccount(String vaultAccountId) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getVaultAccountRequestBuilder(vaultAccountId);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getVaultAccount", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<VaultAccount>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<VaultAccount>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getVaultAccountRequestBuilder(String vaultAccountId) throws ApiException {
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling getVaultAccount");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Get the asset balance for a vault account
   * Returns a wallet for a specific asset of a vault account.
   * @param vaultAccountId The ID of the vault account to return (required)
   * @param assetId The ID of the asset (required)
   * @return CompletableFuture&lt;ApiResponse&lt;VaultAsset&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<VaultAsset>> getVaultAccountAsset(String vaultAccountId, String assetId) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getVaultAccountAssetRequestBuilder(vaultAccountId, assetId);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getVaultAccountAsset", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<VaultAsset>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<VaultAsset>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getVaultAccountAssetRequestBuilder(String vaultAccountId, String assetId) throws ApiException {
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling getVaultAccountAsset");
    }
    // verify the required parameter 'assetId' is set
    if (assetId == null) {
      throw new ApiException(400, "Missing the required parameter 'assetId' when calling getVaultAccountAsset");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * List addresses (Paginated)
   * Returns a paginated response of the addresses for a given vault account and asset.
   * @param vaultAccountId The ID of the vault account to return (required)
   * @param assetId The ID of the asset (required)
   * @param limit  (optional)
   * @param before  (optional)
   * @param after  (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;PaginatedAddressResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<PaginatedAddressResponse>> getVaultAccountAssetAddressesPaginated(String vaultAccountId, String assetId, BigDecimal limit, String before, String after) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getVaultAccountAssetAddressesPaginatedRequestBuilder(vaultAccountId, assetId, limit, before, after);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getVaultAccountAssetAddressesPaginated", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<PaginatedAddressResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<PaginatedAddressResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getVaultAccountAssetAddressesPaginatedRequestBuilder(String vaultAccountId, String assetId, BigDecimal limit, String before, String after) throws ApiException {
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling getVaultAccountAssetAddressesPaginated");
    }
    // verify the required parameter 'assetId' is set
    if (assetId == null) {
      throw new ApiException(400, "Missing the required parameter 'assetId' when calling getVaultAccountAssetAddressesPaginated");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));
    localVarQueryParameterBaseName = "before";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("before", before));
    localVarQueryParameterBaseName = "after";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("after", after));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Get asset balance for chosen assets
   * Gets the assets amount summary for all accounts or filtered accounts.
   * @param accountNamePrefix  (optional)
   * @param accountNameSuffix  (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;List&lt;VaultAsset&gt;&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<List<VaultAsset>>> getVaultAssets(String accountNamePrefix, String accountNameSuffix) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getVaultAssetsRequestBuilder(accountNamePrefix, accountNameSuffix);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getVaultAssets", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<List<VaultAsset>>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<List<VaultAsset>>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getVaultAssetsRequestBuilder(String accountNamePrefix, String accountNameSuffix) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/assets";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "accountNamePrefix";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("accountNamePrefix", accountNamePrefix));
    localVarQueryParameterBaseName = "accountNameSuffix";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("accountNameSuffix", accountNameSuffix));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Get vault balance by asset
   * Gets the vault balance summary for an asset.
   * @param assetId  (required)
   * @return CompletableFuture&lt;ApiResponse&lt;VaultAsset&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<VaultAsset>> getVaultBalanceByAsset(String assetId) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getVaultBalanceByAssetRequestBuilder(assetId);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getVaultBalanceByAsset", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<VaultAsset>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<VaultAsset>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getVaultBalanceByAssetRequestBuilder(String assetId) throws ApiException {
    // verify the required parameter 'assetId' is set
    if (assetId == null) {
      throw new ApiException(400, "Missing the required parameter 'assetId' when calling getVaultBalanceByAsset");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/assets/{assetId}"
        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Hide a vault account in the console
   * Hides the requested vault account from the web console view.
   * @param vaultAccountId The vault account to hide (required)
   * @param idempotencyKey A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;VaultActionStatus&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<VaultActionStatus>> hideVaultAccount(String vaultAccountId, String idempotencyKey) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = hideVaultAccountRequestBuilder(vaultAccountId, idempotencyKey);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("hideVaultAccount", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<VaultActionStatus>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<VaultActionStatus>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder hideVaultAccountRequestBuilder(String vaultAccountId, String idempotencyKey) throws ApiException {
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling hideVaultAccount");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}/hide"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (idempotencyKey != null) {
      localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Assign AML customer reference ID
   * Sets an AML/KYT customer reference ID for a specific address.
   * @param setCustomerRefIdForAddressRequest  (required)
   * @param vaultAccountId The ID of the vault account (required)
   * @param assetId The ID of the asset (required)
   * @param addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address (required)
   * @param idempotencyKey A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;VaultActionStatus&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<VaultActionStatus>> setCustomerRefIdForAddress(SetCustomerRefIdForAddressRequest setCustomerRefIdForAddressRequest, String vaultAccountId, String assetId, String addressId, String idempotencyKey) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = setCustomerRefIdForAddressRequestBuilder(setCustomerRefIdForAddressRequest, vaultAccountId, assetId, addressId, idempotencyKey);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("setCustomerRefIdForAddress", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<VaultActionStatus>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<VaultActionStatus>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder setCustomerRefIdForAddressRequestBuilder(SetCustomerRefIdForAddressRequest setCustomerRefIdForAddressRequest, String vaultAccountId, String assetId, String addressId, String idempotencyKey) throws ApiException {
    // verify the required parameter 'setCustomerRefIdForAddressRequest' is set
    if (setCustomerRefIdForAddressRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'setCustomerRefIdForAddressRequest' when calling setCustomerRefIdForAddress");
    }
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling setCustomerRefIdForAddress");
    }
    // verify the required parameter 'assetId' is set
    if (assetId == null) {
      throw new ApiException(400, "Missing the required parameter 'assetId' when calling setCustomerRefIdForAddress");
    }
    // verify the required parameter 'addressId' is set
    if (addressId == null) {
      throw new ApiException(400, "Missing the required parameter 'addressId' when calling setCustomerRefIdForAddress");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/set_customer_ref_id"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()))
        .replace("{addressId}", ApiClient.urlEncode(addressId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (idempotencyKey != null) {
      localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(setCustomerRefIdForAddressRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Turn autofueling on or off
   * Sets the autofueling property of the vault account to enabled or disabled.
   * @param setAutoFuelRequest  (required)
   * @param vaultAccountId The vault account ID (required)
   * @param idempotencyKey A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;VaultActionStatus&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<VaultActionStatus>> setVaultAccountAutoFuel(SetAutoFuelRequest setAutoFuelRequest, String vaultAccountId, String idempotencyKey) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = setVaultAccountAutoFuelRequestBuilder(setAutoFuelRequest, vaultAccountId, idempotencyKey);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("setVaultAccountAutoFuel", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<VaultActionStatus>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<VaultActionStatus>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder setVaultAccountAutoFuelRequestBuilder(SetAutoFuelRequest setAutoFuelRequest, String vaultAccountId, String idempotencyKey) throws ApiException {
    // verify the required parameter 'setAutoFuelRequest' is set
    if (setAutoFuelRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'setAutoFuelRequest' when calling setVaultAccountAutoFuel");
    }
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling setVaultAccountAutoFuel");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}/set_auto_fuel"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (idempotencyKey != null) {
      localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(setAutoFuelRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Set an AML/KYT customer reference ID for a vault account
   * Assigns an AML/KYT customer reference ID for the vault account.
   * @param setCustomerRefIdRequest  (required)
   * @param vaultAccountId The vault account ID (required)
   * @param idempotencyKey A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;VaultActionStatus&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<VaultActionStatus>> setVaultAccountCustomerRefId(SetCustomerRefIdRequest setCustomerRefIdRequest, String vaultAccountId, String idempotencyKey) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = setVaultAccountCustomerRefIdRequestBuilder(setCustomerRefIdRequest, vaultAccountId, idempotencyKey);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("setVaultAccountCustomerRefId", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<VaultActionStatus>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<VaultActionStatus>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder setVaultAccountCustomerRefIdRequestBuilder(SetCustomerRefIdRequest setCustomerRefIdRequest, String vaultAccountId, String idempotencyKey) throws ApiException {
    // verify the required parameter 'setCustomerRefIdRequest' is set
    if (setCustomerRefIdRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'setCustomerRefIdRequest' when calling setVaultAccountCustomerRefId");
    }
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling setVaultAccountCustomerRefId");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}/set_customer_ref_id"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (idempotencyKey != null) {
      localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(setCustomerRefIdRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Unhide a vault account in the console
   * Makes a hidden vault account visible in web console view.
   * @param vaultAccountId The vault account to unhide (required)
   * @param idempotencyKey A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;VaultActionStatus&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<VaultActionStatus>> unhideVaultAccount(String vaultAccountId, String idempotencyKey) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = unhideVaultAccountRequestBuilder(vaultAccountId, idempotencyKey);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("unhideVaultAccount", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<VaultActionStatus>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<VaultActionStatus>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder unhideVaultAccountRequestBuilder(String vaultAccountId, String idempotencyKey) throws ApiException {
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling unhideVaultAccount");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}/unhide"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (idempotencyKey != null) {
      localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Rename a vault account
   * Renames the requested vault account.
   * @param updateVaultAccountRequest  (required)
   * @param vaultAccountId The ID of the vault account to edit (required)
   * @param idempotencyKey A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;RenameVaultAccountResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<RenameVaultAccountResponse>> updateVaultAccount(UpdateVaultAccountRequest updateVaultAccountRequest, String vaultAccountId, String idempotencyKey) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = updateVaultAccountRequestBuilder(updateVaultAccountRequest, vaultAccountId, idempotencyKey);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("updateVaultAccount", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<RenameVaultAccountResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<RenameVaultAccountResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder updateVaultAccountRequestBuilder(UpdateVaultAccountRequest updateVaultAccountRequest, String vaultAccountId, String idempotencyKey) throws ApiException {
    // verify the required parameter 'updateVaultAccountRequest' is set
    if (updateVaultAccountRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'updateVaultAccountRequest' when calling updateVaultAccount");
    }
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling updateVaultAccount");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (idempotencyKey != null) {
      localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(updateVaultAccountRequest);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Update address description
   * Updates the description of an existing address of an asset in a vault account.
   * @param vaultAccountId The ID of the vault account (required)
   * @param assetId The ID of the asset (required)
   * @param addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address (required)
   * @param updateVaultAccountAssetAddressRequest  (optional)
   * @param idempotencyKey A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;VaultActionStatus&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<VaultActionStatus>> updateVaultAccountAssetAddress(String vaultAccountId, String assetId, String addressId, UpdateVaultAccountAssetAddressRequest updateVaultAccountAssetAddressRequest, String idempotencyKey) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = updateVaultAccountAssetAddressRequestBuilder(vaultAccountId, assetId, addressId, updateVaultAccountAssetAddressRequest, idempotencyKey);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("updateVaultAccountAssetAddress", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<VaultActionStatus>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<VaultActionStatus>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder updateVaultAccountAssetAddressRequestBuilder(String vaultAccountId, String assetId, String addressId, UpdateVaultAccountAssetAddressRequest updateVaultAccountAssetAddressRequest, String idempotencyKey) throws ApiException {
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling updateVaultAccountAssetAddress");
    }
    // verify the required parameter 'assetId' is set
    if (assetId == null) {
      throw new ApiException(400, "Missing the required parameter 'assetId' when calling updateVaultAccountAssetAddress");
    }
    // verify the required parameter 'addressId' is set
    if (addressId == null) {
      throw new ApiException(400, "Missing the required parameter 'addressId' when calling updateVaultAccountAssetAddress");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()))
        .replace("{addressId}", ApiClient.urlEncode(addressId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (idempotencyKey != null) {
      localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(updateVaultAccountAssetAddressRequest);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Refresh asset balance data
   * Updates the balance of a specific asset in a vault account.
   * @param vaultAccountId The ID of the vault account to return (required)
   * @param assetId The ID of the asset (required)
   * @param idempotencyKey A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;VaultAsset&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<VaultAsset>> updateVaultAccountAssetBalance(String vaultAccountId, String assetId, String idempotencyKey) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = updateVaultAccountAssetBalanceRequestBuilder(vaultAccountId, assetId, idempotencyKey);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("updateVaultAccountAssetBalance", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<VaultAsset>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<VaultAsset>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder updateVaultAccountAssetBalanceRequestBuilder(String vaultAccountId, String assetId, String idempotencyKey) throws ApiException {
    // verify the required parameter 'vaultAccountId' is set
    if (vaultAccountId == null) {
      throw new ApiException(400, "Missing the required parameter 'vaultAccountId' when calling updateVaultAccountAssetBalance");
    }
    // verify the required parameter 'assetId' is set
    if (assetId == null) {
      throw new ApiException(400, "Missing the required parameter 'assetId' when calling updateVaultAccountAssetBalance");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/balance"
        .replace("{vaultAccountId}", ApiClient.urlEncode(vaultAccountId.toString()))
        .replace("{assetId}", ApiClient.urlEncode(assetId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (idempotencyKey != null) {
      localVarRequestBuilder.header("Idempotency-Key", idempotencyKey.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
