/*
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

import java.net.MalformedURLException;
import java.net.URL;
import java.security.NoSuchAlgorithmException;
import java.security.interfaces.RSAPrivateKey;
import java.security.spec.InvalidKeySpecException;
import java.time.OffsetDateTime;
import com.fasterxml.jackson.jaxrs.json.JacksonJsonProvider;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.GenericType;
import com.sun.jersey.api.client.config.DefaultClientConfig;
import com.sun.jersey.api.client.filter.GZIPContentEncodingFilter;
import com.sun.jersey.api.client.filter.LoggingFilter;
import com.sun.jersey.api.client.WebResource.Builder;
import com.sun.jersey.multipart.FormDataMultiPart;
import com.sun.jersey.multipart.file.FileDataBodyPart;

import javax.ws.rs.core.Response.Status.Family;
import javax.ws.rs.core.MediaType;

import java.util.Optional;
import java.util.Collection;
import java.util.Map;
import java.util.Map.Entry;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Date;
import java.io.File;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.MessageDigest;
import java.security.PrivateKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;
import java.util.UUID;

import java.time.Instant;
import java.net.URLEncoder;

import java.io.UnsupportedEncodingException;

import java.text.DateFormat;
import org.openapitools.client.auth.Authentication;
import org.openapitools.client.Configuration;
import org.bouncycastle.crypto.digests.SHA256Digest;
import org.bouncycastle.util.encoders.Hex;
import java.util.Base64;
import com.google.gson.Gson;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ApiClient extends JavaTimeFormatter {
    private String basePath = "https://api.fireblocks.io/v1";
    protected Map<String, String> serverVariables = null;
    private boolean debugging = false;
    private int connectionTimeout = 0;
    private static final long EXPIRATION_TIME_IN_SECONDS = 55;
    private Client httpClient;
    private ObjectMapper objectMapper;

    private Map<String, Authentication> authentications;

    private int statusCode;
    private Map<String, List<String>> responseHeaders;

    private DateFormat dateFormat;

    private Configuration configuration;

    public ApiClient() {
        this.objectMapper = new ObjectMapper();
        this.objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        this.objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        this.objectMapper.configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false);
        this.objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        this.objectMapper.enable(SerializationFeature.WRITE_ENUMS_USING_TO_STRING);
        this.objectMapper.enable(DeserializationFeature.READ_ENUMS_USING_TO_STRING);
        this.objectMapper.registerModule(new JavaTimeModule());
        this.objectMapper.setDateFormat(ApiClient.buildDefaultDateFormat());
        this.configuration = new Configuration();
        String basePath = System.getenv("FIREBLOCKS_BASE_PATH");
        String secretKey = System.getenv("FIREBLOCKS_SECRET_KEY");
        String apiKey = System.getenv("FIREBLOCKS_API_KEY");
        if (basePath == null) {
            this.configuration.setBasePath(this.basePath);
        } else {
            this.configuration.setBasePath(basePath);
        }

        if (secretKey == null) {
            throw new NullPointerException("environment variable FIREBLOCKS_SECRET_KEY is missing");
        }

        if (apiKey == null) {
            throw new NullPointerException("environment variable FIREBLOCKS_API_KEY is missing");
        }
        this.configuration.setApiKey(apiKey);
        this.configuration.setSecretKey(secretKey);
        dateFormat = ApiClient.buildDefaultDateFormat();

        rebuildHttpClient();
    }

    public ApiClient(Configuration config) {
        this.objectMapper = new ObjectMapper();
        this.objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        this.objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        this.objectMapper.configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false);
        this.objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        this.objectMapper.enable(SerializationFeature.WRITE_ENUMS_USING_TO_STRING);
        this.objectMapper.enable(DeserializationFeature.READ_ENUMS_USING_TO_STRING);
        this.objectMapper.registerModule(new JavaTimeModule());
        this.objectMapper.setDateFormat(ApiClient.buildDefaultDateFormat());
        this.configuration = config;
        dateFormat = ApiClient.buildDefaultDateFormat();

        // Set default User-Agent.
        // setUserAgent("OpenAPI-Generator/1.5.5/java");

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        //authentications = Collections.unmodifiableMap(authentications);

        rebuildHttpClient();
    }

    public static DateFormat buildDefaultDateFormat() {
        return new RFC3339DateFormat();
    }

    private String getUserAgent() {
    String sdkVersion = System.getProperty("sdk.version");
    String version = "fireblocks-sdk-java/" + sdkVersion;
        String userAgent = version;
        SDKOptions options = this.configuration.getOptions();
        if (!Optional.ofNullable(options)
                .map(sdkOptions -> sdkOptions.getAnonymousPlatform())
                .orElse(false)) {
            String osType = System.getProperty("os.name");
            String osVersion = System.getProperty("os.version");
            String osArch = System.getProperty("os.arch");

            userAgent += " (" + osType + " " + osVersion + "; " + osArch + ")";
        }

        if (Optional.ofNullable(options)
                .map(sdkOptions -> sdkOptions.getUserAgent())
                .isPresent()) {
            String customUserAgent = options.getUserAgent();
            userAgent = customUserAgent + " " + userAgent;
        }

        return userAgent;
    }

    /**
     * Build the Client used to make HTTP requests with the latest settings,
     * i.e. objectMapper and debugging.
     * TODO: better to use the Builder Pattern?
     *
     * @return API client
     */
    public ApiClient rebuildHttpClient() {
        // Add the JSON serialization support to Jersey
        JacksonJsonProvider jsonProvider = new JacksonJsonProvider(objectMapper);
        DefaultClientConfig conf = new DefaultClientConfig();
        conf.getSingletons().add(jsonProvider);
        Client client = Client.create(conf);
        client.addFilter(new GZIPContentEncodingFilter(false));
        if (debugging) {
            client.addFilter(new LoggingFilter());
        }
        SDKOptions options = this.configuration.getOptions();
        Map<String,String> proxy = options.getProxy();
        if(proxy != null){
            System.setProperty("http.proxyHost", proxy.get("proxyHost"));
            System.setProperty("http.proxyPort", proxy.get("proxyPort"));
        }
        this.httpClient = client;
        return this;
    }

    /**
     * Returns the current object mapper used for JSON serialization/deserialization.
     * <p>
     * Note: If you make changes to the object mapper, remember to set it back via
     * <code>setObjectMapper</code> in order to trigger HTTP client rebuilding.
     * </p>
     *
     * @return Object mapper
     */
    public ObjectMapper getObjectMapper() {
        return objectMapper;
    }

    public ApiClient setObjectMapper(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
        // Need to rebuild the Client as it depends on object mapper.
        rebuildHttpClient();
        return this;
    }

    public Client getHttpClient() {
        return httpClient;
    }

    public ApiClient setHttpClient(Client httpClient) {
        this.httpClient = httpClient;
        return this;
    }

    public String getBasePath() {
        return basePath;
    }

    public ApiClient setBasePath(String basePath) {
        this.basePath = basePath;
        return this;
    }

    public Map<String, String> getServerVariables() {
        return serverVariables;
    }

    public ApiClient setServerVariables(Map<String, String> serverVariables) {
        this.serverVariables = serverVariables;
        return this;
    }

    /**
     * Gets the status code of the previous request
     *
     * @return Status code
     */
    public int getStatusCode() {
        return statusCode;
    }

    /**
     * Gets the response headers of the previous request
     *
     * @return Response headers
     */
    public Map<String, List<String>> getResponseHeaders() {
        return responseHeaders;
    }

    /**
     * Get authentications (key: authentication name, value: authentication).
     *
     * @return Map of authentication
     */
    public Map<String, Authentication> getAuthentications() {
        return authentications;
    }

    /**
     * Get authentication for the given name.
     *
     * @param authName The authentication name
     * @return The authentication, null if not found
     */
    public Authentication getAuthentication(String authName) {
        return authentications.get(authName);
    }

    /**
     * Helper method to set access token for the first Bearer authentication.
     *
     * @param bearerToken Bearer token
     * @return API client
     */
    private String getBearerToken(String path, Object obj) throws Exception {
        return "Bearer " + this.signJwt(path, obj);
    }

    private String signJwt(String path, Object bodyJson) throws JsonProcessingException, NoSuchAlgorithmException, InvalidKeySpecException, MalformedURLException {
        String bodyHash = getBodyHash(bodyJson);

        Instant now = Instant.now();
        Date issuedAt = Date.from(now);
        Date expiresAt = Date.from(now.plusSeconds(55));

        Map<String, Object> claims = new HashMap<>();
        claims.put("uri", this.getStrippedUrl(path));
        claims.put("nonce", UUID.randomUUID().toString());
        claims.put("iat", issuedAt.getTime() / 1000);
        claims.put("exp", expiresAt.getTime() / 1000);
        claims.put("sub", this.configuration.getApiKey());
        claims.put("bodyHash", bodyHash);

        Algorithm algorithm = Algorithm.RSA256(null, this.createPrivateKeyFromString(this.configuration.getSecretKey()));
        String token = JWT.create()
                .withClaim("uri", claims.get("uri").toString())
                .withClaim("nonce", claims.get("nonce").toString())
                .withClaim("iat", (Long) claims.get("iat"))
                .withClaim("exp", (Long) claims.get("exp"))
                .withClaim("sub", (String) claims.get("sub"))
                .withClaim("bodyHash", claims.get("bodyHash").toString())
                .sign(algorithm);

        return token;
    }

    private String getBodyHash(Object bodyJson) throws JsonProcessingException, JsonProcessingException, NoSuchAlgorithmException {
        try {
            Gson gson = new Gson();
            String json = gson.toJson(bodyJson == null ? "" : bodyJson);
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hashBytes = digest.digest(json.getBytes());
            return bytesToHex(hashBytes);
        } catch (NoSuchAlgorithmException e) {
            // Handle the exception
            return "";
        }
    }

    private String bytesToHex(byte[] hash) {
        StringBuilder hexString = new StringBuilder(2 * hash.length);
        for (int i = 0; i < hash.length; i++) {
            String hex = Integer.toHexString(0xff & hash[i]);
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        return hexString.toString();
    }

    private String getStrippedUrl(String path) throws MalformedURLException {
        return new URL(this.configuration.getBasePath() + path).getPath();
    }

    private RSAPrivateKey createPrivateKeyFromString(String privateKeyString) throws NoSuchAlgorithmException, InvalidKeySpecException {
        // Remove the "BEGIN PRIVATE KEY" and "END PRIVATE KEY" headers and newlines
        String strippedKey = new String(this.configuration.getSecretKey().getBytes(), StandardCharsets.UTF_8).replaceAll("-----(BEGIN|END) PRIVATE KEY-----", "").replaceAll("\\s", "");

        // Base64-decode the stripped key
        byte[] keyBytes = Base64.getDecoder().decode(strippedKey);

        // Create the PKCS8EncodedKeySpec from the decoded key bytes
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);

        // Get the RSA key factory and generate the private key
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        PrivateKey privateKey = keyFactory.generatePrivate(spec);

        // Cast the private key to RSAPrivateKey
        RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) privateKey;

        return rsaPrivateKey;
    }


    public PrivateKey getPrivateKey() throws Exception {
        String privateKeyContent = new String(this.configuration.getSecretKey().getBytes(), StandardCharsets.UTF_8).replaceAll("-----(BEGIN|END) PRIVATE KEY-----", "").replaceAll("\\s", "");

        byte[] certificateBytes = Base64.getDecoder().decode(
                privateKeyContent
        );

        KeyFactory kf = KeyFactory.getInstance("RSA");
        PKCS8EncodedKeySpec keySpecPKCS8 = new PKCS8EncodedKeySpec(certificateBytes);

        PrivateKey privateKey = kf.generatePrivate(keySpecPKCS8);
        return privateKey;
    }


    /**
     * Connect timeout (in milliseconds).
     *
     * @return Connection timeout
     */
    public int getConnectTimeout() {
        return connectionTimeout;
    }

    /**
     * Set the connect timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link Integer#MAX_VALUE}.
     *
     * @param connectionTimeout Connection timeout in milliseconds
     * @return API client
     */
    public ApiClient setConnectTimeout(int connectionTimeout) {
        this.connectionTimeout = connectionTimeout;
        httpClient.setConnectTimeout(connectionTimeout);
        return this;
    }

    /**
     * Get the date format used to parse/format date parameters.
     *
     * @return Date format
     */
    public DateFormat getDateFormat() {
        return dateFormat;
    }

    /**
     * Set the date format used to parse/format date parameters.
     *
     * @param dateFormat Date format
     * @return API client
     */
    public ApiClient setDateFormat(DateFormat dateFormat) {
        this.dateFormat = dateFormat;
        // Also set the date format for model (de)serialization with Date properties.
        this.objectMapper.setDateFormat((DateFormat) dateFormat.clone());
        // Need to rebuild the Client as objectMapper changes.
        rebuildHttpClient();
        return this;
    }

    /**
     * Parse the given string into Date object.
     *
     * @param str String
     * @return Date
     */
    public Date parseDate(String str) {
        try {
            return dateFormat.parse(str);
        } catch (java.text.ParseException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Format the given Date object into string.
     *
     * @param date Date
     * @return Date in string format
     */
    public String formatDate(Date date) {
        return dateFormat.format(date);
    }

    /**
     * Format the given parameter object into string.
     *
     * @param param Object
     * @return Object in string format
     */
    public String parameterToString(Object param) {
        if (param == null) {
            return "";
        } else if (param instanceof Date) {
            return formatDate((Date) param);
        } else if (param instanceof OffsetDateTime) {
            return formatOffsetDateTime((OffsetDateTime) param);
        } else if (param instanceof Collection) {
            StringBuilder b = new StringBuilder();
            for (Object o : (Collection<?>) param) {
                if (b.length() > 0) {
                    b.append(',');
                }
                b.append(String.valueOf(o));
            }
            return b.toString();
        } else {
            return String.valueOf(param);
        }
    }

    /**
     * Formats the specified query parameter to a list containing a single {@code Pair} object.
     * <p>
     * Note that {@code value} must not be a collection.
     *
     * @param name  The name of the parameter.
     * @param value The value of the parameter.
     * @return A list containing a single {@code Pair} object.
     */
    public List<Pair> parameterToPair(String name, Object value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null || value instanceof Collection) return params;

        params.add(new Pair(name, parameterToString(value)));
        return params;
    }

    /**
     * Formats the specified collection query parameters to a list of {@code Pair} objects.
     * <p>
     * Note that the values of each of the returned Pair objects are percent-encoded.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param name             The name of the parameter.
     * @param value            The value of the parameter.
     * @return A list of {@code Pair} objects.
     */
    public List<Pair> parameterToPairs(String collectionFormat, String name, Collection value) {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if (name == null || name.isEmpty() || value == null) {
            return params;
        }

        // create the params based on the collection format
        if ("multi".equals(collectionFormat)) {
            for (Object item : value) {
                params.add(new Pair(name, escapeString(parameterToString(item))));
            }
            return params;
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        // escape all delimiters except commas, which are URI reserved
        // characters
        if ("ssv".equals(collectionFormat)) {
            delimiter = escapeString(" ");
        } else if ("tsv".equals(collectionFormat)) {
            delimiter = escapeString("\t");
        } else if ("pipes".equals(collectionFormat)) {
            delimiter = escapeString("|");
        }

        StringBuilder sb = new StringBuilder();
        for (Object item : value) {
            sb.append(delimiter);
            sb.append(escapeString(parameterToString(item)));
        }

        params.add(new Pair(name, sb.substring(delimiter.length())));

        return params;
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     * application/json
     * application/json; charset=UTF8
     * APPLICATION/JSON
     * application/vnd.company+json
     *
     * @param mime MIME
     * @return True if MIME type is boolean
     */
    public boolean isJsonMime(String mime) {
        String jsonMime = "(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$";
        return mime != null && (mime.matches(jsonMime) || mime.equals("*/*"));
    }

    /**
     * Select the Accept header's value from the given accepts array:
     * if JSON exists in the given array, use it;
     * otherwise use all of them (joining into a string)
     *
     * @param accepts The accepts array to select from
     * @return The Accept header to use. If the given array is empty,
     * null will be returned (not to set the Accept header explicitly).
     */
    public String selectHeaderAccept(String[] accepts) {
        if (accepts.length == 0) {
            return null;
        }
        for (String accept : accepts) {
            if (isJsonMime(accept)) {
                return accept;
            }
        }
        return StringUtil.join(accepts, ",");
    }

    /**
     * Select the Content-Type header's value from the given array:
     * if JSON exists in the given array, use it;
     * otherwise use the first one of the array.
     *
     * @param contentTypes The Content-Type array to select from
     * @return The Content-Type header to use. If the given array is empty,
     * or matches "any", JSON will be used.
     */
    public String selectHeaderContentType(String[] contentTypes) {
        if (contentTypes.length == 0 || contentTypes[0].equals("*/*")) {
            return "application/json";
        }
        for (String contentType : contentTypes) {
            if (isJsonMime(contentType)) {
                return contentType;
            }
        }
        return contentTypes[0];
    }

    /**
     * Escape the given string to be used as URL query value.
     *
     * @param str String
     * @return Escaped string
     */
    public String escapeString(String str) {
        try {
            return URLEncoder.encode(str, "utf8").replaceAll("\\+", "%20");
        } catch (UnsupportedEncodingException e) {
            return str;
        }
    }

    /**
     * Serialize the given Java object into string according the given
     * Content-Type (only JSON is supported for now).
     *
     * @param obj         Object
     * @param contentType Content type
     * @param formParams  Form parameters
     * @return Object
     * @throws ApiException API exception
     */
    public Object serialize(Object obj, String contentType, Map<String, Object> formParams) throws ApiException {
        if (contentType.startsWith("multipart/form-data")) {
            FormDataMultiPart mp = new FormDataMultiPart();
            for (Entry<String, Object> param : formParams.entrySet()) {
                if (param.getValue() instanceof List && !((List) param.getValue()).isEmpty()
                        && ((List) param.getValue()).get(0) instanceof File) {
                    @SuppressWarnings("unchecked")
                    List<File> files = (List<File>) param.getValue();
                    for (File file : files) {
                        mp.bodyPart(new FileDataBodyPart(param.getKey(), file, MediaType.APPLICATION_OCTET_STREAM_TYPE));
                    }
                } else if (param.getValue() instanceof File) {
                    File file = (File) param.getValue();
                    mp.bodyPart(new FileDataBodyPart(param.getKey(), file, MediaType.APPLICATION_OCTET_STREAM_TYPE));
                } else {
                    mp.field(param.getKey(), parameterToString(param.getValue()), MediaType.MULTIPART_FORM_DATA_TYPE);
                }
            }
            return mp;
        } else if (contentType.startsWith("application/x-www-form-urlencoded")) {
            return this.getXWWWFormUrlencodedParams(formParams);
        } else {
            // We let Jersey attempt to serialize the body
            Gson gson = new Gson();
            String json = gson.toJson(obj == null ? "" : obj);
            return obj;
        }
    }

    /**
     * Build full URL by concatenating base path, the given sub path and query parameters.
     *
     * @param path                  The sub path
     * @param queryParams           The query parameters
     * @param collectionQueryParams The collection query parameters
     * @return The full URL
     */
    private String buildUrl(String path, List<Pair> queryParams, List<Pair> collectionQueryParams) {
        String baseURL = this.configuration.getBasePath();
        final StringBuilder url = new StringBuilder();
        url.append(baseURL).append(path);

        if (queryParams != null && !queryParams.isEmpty()) {
            // support (constant) query string in `path`, e.g. "/posts?draft=1"
            String prefix = path.contains("?") ? "&" : "?";
            for (Pair param : queryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    url.append(escapeString(param.getName())).append("=").append(escapeString(value));
                }
            }
        }

        if (collectionQueryParams != null && !collectionQueryParams.isEmpty()) {
            String prefix = url.toString().contains("?") ? "&" : "?";
            for (Pair param : collectionQueryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    // collection query parameter value already escaped as part of parameterToPairs
                    url.append(escapeString(param.getName())).append("=").append(value);
                }
            }
        }

        return url.toString();
    }

    private ClientResponse getAPIResponse(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String accept, String contentType, String[] authNames) throws ApiException {
        if (body != null && !formParams.isEmpty()) {
            throw new ApiException(500, "Cannot have body and form params");
        }
        final String url = buildUrl(path, queryParams, collectionQueryParams);
        Builder builder;
        System.out.println(url);
        if (accept == null) {
            builder = httpClient.resource(url).getRequestBuilder();
        } else {
            builder = httpClient.resource(url).accept(accept);
        }
        try {
            String pKey = this.getBearerToken(path, body);
            builder = builder.header("Authorization", this.getBearerToken(path, body));
            System.out.println(pKey);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        builder = builder.header("X-API-Key", this.configuration.getApiKey());
        builder = builder.header("User-Agent", this.getUserAgent());
        System.out.println(serialize(body, contentType, formParams));


        ClientResponse response = null;

        if ("GET".equals(method)) {
            response = (ClientResponse) builder.get(ClientResponse.class);
        } else if ("POST".equals(method)) {
            response = builder.type(contentType).post(ClientResponse.class, serialize(body, contentType, formParams));
        } else if ("PUT".equals(method)) {
            response = builder.type(contentType).put(ClientResponse.class, serialize(body, contentType, formParams));
        } else if ("DELETE".equals(method)) {
            response = builder.type(contentType).delete(ClientResponse.class, serialize(body, contentType, formParams));
        } else if ("PATCH".equals(method)) {
            response = builder.type(contentType).header("X-HTTP-Method-Override", "PATCH").post(ClientResponse.class, serialize(body, contentType, formParams));
        } else if ("HEAD".equals(method)) {
            response = builder.head();
        } else {
            throw new ApiException(500, "unknown method type " + method);
        }
        return response;
    }

    /**
     * Invoke API by sending HTTP request with the given options.
     *
     * @param <T>                   Type
     * @param path                  The sub-path of the HTTP URL
     * @param method                The request method, one of "GET", "POST", "PUT", and "DELETE"
     * @param queryParams           The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body                  The request body object - if it is not binary, otherwise null
     * @param headerParams          The header parameters
     * @param cookieParams          The cookie parameters
     * @param formParams            The form parameters
     * @param accept                The request's Accept header
     * @param contentType           The request's Content-Type header
     * @param authNames             The authentications to apply
     * @param returnType            Return type
     * @return The response body in type of string
     * @throws ApiException API exception
     */
    public <T> T invokeAPI(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, String> cookieParams, Map<String, Object> formParams, String accept, String contentType, String[] authNames, GenericType<T> returnType) throws ApiException {
        ClientResponse response = getAPIResponse(path, method, queryParams, collectionQueryParams, body, headerParams, cookieParams, formParams, accept, contentType, authNames);

        statusCode = response.getStatusInfo().getStatusCode();
        responseHeaders = response.getHeaders();

        if (response.getStatusInfo().getStatusCode() == ClientResponse.Status.NO_CONTENT.getStatusCode()) {
            return null;
        } else if (response.getStatusInfo().getFamily() == Family.SUCCESSFUL) {
            if (returnType == null)
                return null;
            else
                return response.getEntity(returnType);
        } else {
            String message = "error";
            String respBody = null;
            if (response.hasEntity()) {
                try {
                    respBody = response.getEntity(String.class);
                    message = respBody;
                } catch (RuntimeException e) {
                    // e.printStackTrace();
                }
            }
            throw new ApiException(
                    response.getStatusInfo().getStatusCode(),
                    message,
                    response.getHeaders(),
                    respBody);
        }
    }

    /**
     * Update query and header parameters based on authentication settings.
     *
     * @param authNames    The authentications to apply
     * @param queryParams  Query parameters
     * @param headerParams Header parameters
     * @param cookieParams Cookie parameters
     */
    private void updateParamsForAuth(String[] authNames, List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams) {
        for (String authName : authNames) {
            Authentication auth = authentications.get(authName);
            if (auth == null) throw new RuntimeException("Authentication undefined: " + authName);
            auth.applyToParams(queryParams, headerParams, cookieParams);
        }
    }

    /**
     * Encode the given form parameters as request body.
     *
     * @param formParams Form parameters
     * @return HTTP form encoded parameters
     */
    private String getXWWWFormUrlencodedParams(Map<String, Object> formParams) {
        StringBuilder formParamBuilder = new StringBuilder();

        for (Entry<String, Object> param : formParams.entrySet()) {
            String valueStr = parameterToString(param.getValue());
            try {
                formParamBuilder.append(URLEncoder.encode(param.getKey(), "utf8"))
                        .append("=")
                        .append(URLEncoder.encode(valueStr, "utf8"));
                formParamBuilder.append("&");
            } catch (UnsupportedEncodingException e) {
                // move on to next
            }
        }

        String encodedFormParams = formParamBuilder.toString();
        if (encodedFormParams.endsWith("&")) {
            encodedFormParams = encodedFormParams.substring(0, encodedFormParams.length() - 1);
        }

        return encodedFormParams;
    }
}
