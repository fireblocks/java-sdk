/*
 * Fireblocks API
 * Fireblocks provides a suite of applications to manage digital asset operations and a complete development platform to build your business on the blockchain.  - Visit our website for more information: [Fireblocks Website](https://fireblocks.com) - Visit our developer docs: [Fireblocks DevPortal](https://developers.fireblocks.com)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: developers@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.fireblocks.sdk.api;


import com.fireblocks.sdk.ApiException;
import com.fireblocks.sdk.ApiResponse;
import com.fireblocks.sdk.model.CreateSigningKeyDto;
import com.fireblocks.sdk.model.CreateValidationKeyDto;
import com.fireblocks.sdk.model.CreateValidationKeyResponseDto;
import com.fireblocks.sdk.model.GetSigningKeyResponseDto;
import com.fireblocks.sdk.model.GetValidationKeyResponseDto;
import com.fireblocks.sdk.model.ModifySigningKeyAgentIdDto;
import com.fireblocks.sdk.model.ModifySigningKeyDto;
import com.fireblocks.sdk.model.ModifyValidationKeyDto;
import com.fireblocks.sdk.model.SigningKeyDto;
import com.fireblocks.sdk.model.ValidationKeyDto;
import java.math.BigDecimal;
import java.util.concurrent.CompletableFuture;
import org.junit.Ignore;
import org.junit.Test;

/** API tests for KeyLinkBetaApi */
@Ignore
public class KeyLinkBetaApiTest {

    private final KeyLinkBetaApi api = new KeyLinkBetaApi();

    /**
     * Add a new signing key
     *
     * <p>Adds a new signing key to the workspace. The added key will be linked to the specific
     * Fireblocks agent user ID. The same user will receive the proof of ownership message to be
     * signed, and upon successful proof, the key will become enabled.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createSigningKeyTest() throws ApiException {
        CreateSigningKeyDto createSigningKeyDto = null;
        String idempotencyKey = null;
        CompletableFuture<ApiResponse<SigningKeyDto>> response =
                api.createSigningKey(createSigningKeyDto, idempotencyKey);
    }

    /**
     * Add a new validation key
     *
     * <p>Adds a new validation key used to validate signing keys. The new validation key will
     * undergo an approval process by the workspace quorum.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createValidationKeyTest() throws ApiException {
        CreateValidationKeyDto createValidationKeyDto = null;
        String idempotencyKey = null;
        CompletableFuture<ApiResponse<CreateValidationKeyResponseDto>> response =
                api.createValidationKey(createValidationKeyDto, idempotencyKey);
    }

    /**
     * Disables a validation key
     *
     * <p>Allows disabling validation key even if it has not expired yet. It is not allowed to
     * enable the validation key back. Another key has to be used for future validations.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void disableValidationKeyTest() throws ApiException {
        ModifyValidationKeyDto modifyValidationKeyDto = null;
        String keyId = null;
        CompletableFuture<ApiResponse<ValidationKeyDto>> response =
                api.disableValidationKey(modifyValidationKeyDto, keyId);
    }

    /**
     * Get a signing key by &#x60;keyId&#x60;
     *
     * <p>Returns a signing key if it exists, identified by the specified &#x60;keyId&#x60;.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSigningKeyTest() throws ApiException {
        String keyId = null;
        CompletableFuture<ApiResponse<SigningKeyDto>> response = api.getSigningKey(keyId);
    }

    /**
     * Get list of signing keys
     *
     * <p>Returns the list of signing keys in the workspace
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSigningKeysListTest() throws ApiException {
        String pageCursor = null;
        BigDecimal pageSize = null;
        String sortBy = null;
        String order = null;
        BigDecimal vaultAccountId = null;
        String agentUserId = null;
        String algorithm = null;
        Boolean enabled = null;
        Boolean available = null;
        Boolean isAssigned = null;
        String keyPrefix = null;
        CompletableFuture<ApiResponse<GetSigningKeyResponseDto>> response =
                api.getSigningKeysList(
                        pageCursor,
                        pageSize,
                        sortBy,
                        order,
                        vaultAccountId,
                        agentUserId,
                        algorithm,
                        enabled,
                        available,
                        isAssigned,
                        keyPrefix);
    }

    /**
     * Get a validation key by &#x60;keyId&#x60;
     *
     * <p>Returns a validation key if it exists, identified by the specified &#x60;keyId&#x60;.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getValidationKeyTest() throws ApiException {
        String keyId = null;
        CompletableFuture<ApiResponse<ValidationKeyDto>> response = api.getValidationKey(keyId);
    }

    /**
     * Get list of registered validation keys
     *
     * <p>Returns the list of validation keys in the workspace
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getValidationKeysListTest() throws ApiException {
        String pageCursor = null;
        BigDecimal pageSize = null;
        String sortBy = null;
        String order = null;
        CompletableFuture<ApiResponse<GetValidationKeyResponseDto>> response =
                api.getValidationKeysList(pageCursor, pageSize, sortBy, order);
    }

    /**
     * Set agent user id
     *
     * <p>Can modify existing signing key id if the key is not enabled. The change done in
     * background and will be visible once applied. If key is already enabled (after proof of
     * ownership) the user cannot be changed.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setAgentIdTest() throws ApiException {
        ModifySigningKeyAgentIdDto modifySigningKeyAgentIdDto = null;
        String keyId = null;

        CompletableFuture<ApiResponse<Void>> response =
                api.setAgentId(modifySigningKeyAgentIdDto, keyId);
    }

    /**
     * Modify the signing keyId
     *
     * <p>Allows assigning the signing key to a vault account, if it hasn&#39;t been assigned to any
     * other vault accounts yet.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateSigningKeyTest() throws ApiException {
        ModifySigningKeyDto modifySigningKeyDto = null;
        String keyId = null;
        CompletableFuture<ApiResponse<SigningKeyDto>> response =
                api.updateSigningKey(modifySigningKeyDto, keyId);
    }
}
